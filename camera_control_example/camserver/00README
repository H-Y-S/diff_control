Camserver is a completely freestanding program that controls an x-ray camera and provides a simple user interface for "atomic" (single function) commands.  It is intended to provide a spartan, but fully functional, low level interface to camera hardware.

Camserver takes a single command-line argument, the path to the resource file.  Camserver will also use the same path to open its debugging file, 'camdbg.out'.

A major function of camserver is to accept socket connections from a high level controller (e.g., tvx), which can provide high level services to this or other cameras.  The interface is a simple text-based message passing system.  Images - the ultimate product of a working area x-ray detector - do not pass thru the interface, but are written to a configurable location (e.g., a nfs mount) where any program can access them.

Because of the socket connection protocol, the camera hardware and server can reside on a different machine from the high level controller.

Camserver implements a token mechanism (controllingProcess) to prevent more than one outside process from having control over the hardware.  The camserver window has full control at all times.

Commands in camserver that are also present in the tvx main window must have different names to prevent collisions between the enum's in camclient.c and in tvx.c.  I have chosen to distinguish them by upper-casing the last letter (e.g., Run in tvx.c, RuN in camserver.c), and re-lower the case of the last letter in menu_print to make it look better.  This is generally poor prctice in C, but since these commands have the same function in the two places, I see no harm.  Alternatives would be leading or trailing underscores, all upper-case in one window, or slightly respelling commands.

To permit all processes to inquire as to the state of the camera system, I implemented a /proc-like file system, called camstat, which at all times has the camera status, and which can be queried by any process (just 'cat' from the command line will work, too).  Alternatives would have been: use of threads (__clone) rather than fork, so that all child processes share memory; use of shared memory (shmop, etc.); or use of pipes.  Of course, programmers must see to it that these status values are always updated.

A side-effect of the daemon structure of camserver is that a new instantiation of the server (created by connecting a client to it) inherits the default values of any variables in the camera-specific part of the code, rather than any changed settings commanded in another instantiation.  For example, suppose that the camera-specific code contains the base addresses of patterns that can be executed in a VME pattern generator (see sls1bank/tvxcampkg.c).  These addresses have compiled-in default values, but they may be changed by commands from tvx.  If tvx disconnects to allow a beamline controller to assume command, the new instance of the server created by the connection from the beamline controller will have the compiled-in defaults, rather than the values programmed from tvx because the instance that serviced tvx is now gone.  Or if a second client connects after tvx has set variables, the second client will see the defaults, not the new settings.  A mechanism is provided in the camstat system whereby a programmer can save new values from one instance which will be automatically loaded when a new instance fires up.  (See programming below)


--- Organization:

I will use 'slsp2det_cam' as an example of detector-specific code, but as you can see in the source tree, there are several others now.

cam_config.h - locations of configuration files & names of configurable vars

camrc - camera resource file read at startup
~/.camrc - your customized copy of camrc, read after the system file.
    These can be used to configure the camera status reporting system and
    the location of the camera definition.  
    
./camrc - project-specific camera resource file in your project directory
    This is read after ~/.camrc, and overwrites previous global settings

These various "camrc" files are read and interpreted by code in
    ./camserver/slsp2det_cam/util/cam_config.c, which may be extended with new items as
     needed.

camera.def - the camera hardware definition
    The camera definition file is specified in the 'camrc' file and is read and
    interpreted by code in, e.g., ./camserver/slsp2det_cam/util/cam_tbl.c, that is, in
    the camera-specific directory.  As above, this may be extended with new
    items as needed.  New camera definition files can be reread/replaced
    from the command line during camera operation.

camserver.c - main program
camserver.h - declarations for the server.  Needed also by the client (tvx)
slsp2det_cam.pkg - a package of commands specific to one equipment.
    The reading of, e.g., sls_05_16_1.def is compiled into the slsp2det_cam 
    directory tree.  
slsp2det_cam/util/cam_config.c - the detector-specific configuration reader (see above).  Each camera provides its own configuration reader, which should minimally read all the parameters contianined in the example, demo_cam/util/cam_config.c.

--- Paths:

camstat_path - path to the /proc-like filesystem that tracks camera status
cam_data_path - default path for camera data
cam_image_path - place to put images for stand-alone operation
    Note that the image path is normally provided by the client in the 
    'exposure' command.

--- Files:

cam_definition_file - hardware-specific configuration of camera containing
    values of camera variables, e.g. width, height, bits-per-pixel
cam_startup_file - camera-specific commands to executed at startup.  Note that
    this function could equally well be accomplished in the tvx startup file.

--- Initialization:

Each camera type should be configured in its own directory, following the model of the slsp2det_cam directory.  The concept is (though it may fail in practice) that camserver, and its 'utils' are fairly generic, and that the personality of particular camera is brought about by the association with a camera-specific directory.  This is all controlled by reasonably straight-forward changes in ./camserver/Makefile (and only there).  Of course, you have to write the camera code for your camera.

Summary - (slsp2det_cam setup)
1. camserver calls cam_config_initialize(path) in slsp2det_cam/util/cam_config.c
     which calls camera_read_setup(filename) in slsp2det_/util/interface.c
        which calls read_camera_setup(filename) in slsp2det_cam/util/interface.c
           which calls read_detector_info(filename) in slsp2det_cam/progi2c/signals.c
2. camserver calls camera_initialize(void) in slsp2det_/util/interface.c
     which currently is a no-op
3. camserver command 'read_setup filename' calls camera_read_setup (filename)
     which repeats the steps above.

In more detail - 
camserver.c invokes cam_config_initialize (in cam_config.c) supplying the path to the resource file (camrc) supplied in the invocation line.

cam_config_initialize reads (1) the system config file (/usr/local/etc/camrc); (2) the local config file (./camrc); and then (3) the user config file ($HOME/.camrc).  These overwrite previous data in that order.  Thus, the user can have differing configurations in each of several experiment-related directories, or simply a single configuration in his personal .camrc.  It is probably a bad idea to rely on the system default - it will normally point to /tmp, which is guaranteed writable by everyone, but wherein data is insecure.

If a 'camera_definition_file' is specified in the config file, read_camera_setup (in hardware-specific directory slsp2det_/util/cam_tbl.c) is invoked to read camera-specific parameters.  This action may be repeated from the command line by the Read_setup command.  The camera table contains operational parameters for the camera such as image height, width, bpp, bin-factor, etc.  This may be extended to include parameters specific for one kind of hardware, or those variables may be read separately in an application specific package (see next).

camserver.c then invokes read_detector_info (in signals.c, an application specific package).  This reads the camera hardware definition from a file in the cam_data_path directory (default is ./cam_data; the file is specified in 'pix_detector.h' ). 

camserver.c finally reads and executes the cam_startup_file specified in the resource file, if any.


----- IP ADDRESSES

Camserver figures out its own IP address by querying the operating system.  But, on computers configured by DHCP without a fixed IP address, this query returns 'localhost' (127.0.0.1), derived from the entries in /etc/hosts (see camdbg.out to see what IP address was configured).   See gethostbyname(3) for more information.

The easiest way to fix this is to add a line to '/etc/hosts' giving the real IP address and name of the computer (the camserver host).

Otherwise, if tvx is running in the same box as camserver, configure tvx (in tvxrc) to look to 127.0.0.1 for its camera, and all is well.  But, this is useless if tvx is running on a different computer.  For that case, uncomment the line in camserver.c that reads:
        serverName.sin_addr.s_addr = htonl(INADDR_ANY);
(near line 639).  This allows camserver to be reached both at 127.0.0.1, and at the address assigned by DHCP.  Note that the IP address assigned by DHCP is not guaranteed to stay the same from one boot-up to the next, but in fact DHCP servers try to keep the IP address assignment constant.


----- HOW TO ADD A NEW CAMERA:

Camserver is now organized to make configuring for a new camera fairly easy.  The concept is that camserver and its associated utilities are fairly generic, and the real personality of a detector is carried in a subdirectory devoted to the camera.  Camserver isssues calls to, e.g., camera_start(), which is defined in interface.c, in the util directory of the specific camera.  The avoids most of the messy conditional compilation that could arise.  

The steps to create a new camera are (use the name of your choice in place of new_cam):
(1) create a new directory for the camera by copying demo_cam in its entirety:
    cd ./tvx/camera/camserver
    cp -a demo_cam new_cam
(2) in ./new_cam, optionally change the name of the package to "new_cam.pkg" 
           (to avoid confusion), and link tvxcampkg.c to it:
           mv demo_cam.pkg new_cam.pkg
           ln -snf new_cam.pkg tvxcampkg.c
(3) in ./camserver/Makefile, add CAMERA = NEW_CAMERA, and comment out all
           cameras
(4) in ./camserver/Makefile, add an 'ifeq' case for NEW_CAMERA, and set the 
            package name to match the name of the directory you just created.
(5) change ./camserver/new_cam/util/cam_config.c to suit your needs
(6) change ./camserver/new_cam/util/inteface.c to suit your needs
(7) edit ./camserver/camrc to point to your configuration data
(8) issue 'make distclean; make' in the ./camserver directory
That should do it.  Of course now you must build all your hardware specific code.

To use 'make' in the individual directories (convenient for debugging), it is necessary to use the same order as in the Makefile in ./camserver, namely:
    ./camserver/misc
    ./camserver/util
    ./camserver/new_camera/util
    ./camserver/new_camera/(other directories)
if you use 'make distclean' in any directory, it erases the library, so you must repeat these steps.

Considerable care has been taken to minimize the formidable task of adding a new camera to the system.  The base parts of tvx and camserver are supposed to be general-purpose and to have as little of camera-specific code as possible.  The camera-specific components to give tvx its specific personality are conditionally 'included' by '#ifdef' during compilation.  These are then turned on by statements in the makefiles.  If you decide to add a new camera, look in the following places for camera-specific codes:
    ./tvx.c
    ./externs.c
    ./include/camserver.h
    ./include/tvx.h
    ./include/tvxsys.h
    ./camera/camserver/camserver.c (3 places)
    ./camera/camserver/util/cam_config.c
    ./camera/camserver/include/cam_config.h
These components are then selected (or controlled) by definitions in the 2 principle Makefiles:
    ./Makefile
    ./camera/camserver/Makefile
Note that in these mMakefiles, exactly 1 camera must be selected.

Of course, you must still write the code for your new camera.  I recommend starting a new directory parallel to one of the existing camera-specific directories, and writing as much as possible by just modifying code that is already present - there are many examples available.


----- USING ./camstat/variables:

As explained above, the './camstat/variables' file can be used to propagate non-default values of user variables across instances of the server.  This file is emptied (or created) when camserver is invoked, and is read every time a new instance is instantiated.  Its format is identical to that of 'camrc', namely each line contains the name of a variable and a value.  The name of the variable is interpreted as a command to set that variable in cam_config.c.  To use this facility, whenever a variable (that is to be saved) is changed, use camera_record_variable() to make an entry into the file './camstat/variables'.  You also need to register the new command in the switch-case statement near line 197 of cam_config.c.  For example, suppose that the base address of the i2c programming pattern for the VME pattern generator is called 'i2c_pattern_base'.  This is compiled into the camera-specific code, and has a default value of 0x7800.  But this can be changed by a command (from tvx, or typed in the camserver window).  The command to change the address is implemented in tvxcampkg.c as:

    case Base_i2cpat:        // pick up pattern address
        sscanf(ptr, "%i", &i2c_pattern_base);
        camera_record_variable(I2c_pattern_base, ptr); // in ./camstat/variables
        break;

Thus, typing 'base_i2cpat 0x5800) will set a new value.  'I2c_pattern_base' (note upper case I) is the name of the *command* to set the value of the variable (i2c_pattern_base) in the set_configuration() function of cam_config.c.  The string 'ptr' is the text to set the variable from the keyboard.  The configuration command is implemented in cam_config.c as:

    case I2c_pattern_base:        // define command
        sscanf(p, "%i", &i2c_pattern_base);        // set variable from text
        break;

In the standard tvx method, this at once defines the command 'I2c_pattern_base', and makes the definition available to the entire system through cam_config.h.  The variable and the command should have the same spelling, differing only in the case pattern (a case-insensitive compare should find them to be identical).


----- DEBUGGING:

Many errors may be displayed until the configuration is correct, and these will scroll out of the window, or worse exit, before you can read them.  To debug the startup, cd to the camserver directory, and in a large window invoke the camserver directly (not from 'runtvx') giving as argument the (optional) path to the resource file (camrc) you are using; e.g.:
    cd ./tvx/camera/camserver
    ./camserver /home/efe/testtvx
My directory testtvx has a 'camrc' file in it (also a 'tvxrc' file).

Or, look at camdbg.out where initialization steps and errors are displayed in detail.

For a bare-bones interface to camserver, you can telnet to it, and exercise it manually.  Use "telnet <computer_name> 41234".  


----- COMMANDS:

These are the commands in the base module, without camera-specific packages:

CamCmd        - client entry to interpreter - used in tvx to send commands to
                camserver (that camserver understands) without programming tvx
CamSetup      - report camera status/setup
CamWait       - wait for an exposure to end, or program a wait state
DataPath      - set or show cam_data_path
Df            - report the space available in the current path
ExpEnd        - end an exposure before time-out
Exposure      - make an exposure, argument is filename (time and shutter control
                should be preset
ExpTime       - set the exposure time
HeaderString  - a line to include in image file header
ImgPath       - read or set the camserver image path
LdCommandFile - load a file of camera commands and execute them 
Read_setup    - read a hardware-specific camera setup from a file, 
                   e.g. camera.def
K             - stop an exposure in progress
ResetCam      - =K
Send          - send a message to the client (tvx)
ShowPID       - show PID of this process
ShutterEnable - enable/disable shutter control
TelemetrY     - report camera telemetry
ExiT
QuiT
MenU          - type the menu of all commands, including camera specific

If debugging is enabled at compile time, the following are defined:
CamNoop       - null operation
DbglvL        - print or set the debugging level 



----- FIXING THE CASE ASSIGNMENTS

The cases you implement in a camera-specific add-in package are fragile, in the sense that the "typedef enum" in the header is redefined each time the program is compiled.  This opens the possibility that a fresh compilation of tvx on one machine may be out of sync with an older compilation of camserver on another machine, leading potentially to misintrepretation of commands.  A rigorous policy of always adding new cases only to the end of the dispatch loop will prevent this.  But if cases are later removed in particular implementations, problems can arise.

To permit camserver to be implemented across heterogeneous environments, and on different machines, a mechanism is provided to fix the cases by assigning a value to part or all of the definitions in the "typedef enum" in camserver.h.  When camserver is recompiled, the program misc/mkheader is invoked to rewrite the header file with a new "typedef enum" assembled from source code: the files  camserver.c and its included tvxcampkg.c.  misc/mkheader will look for a file named "camserver_casedefs.txt" in the camera-specific include directory (e.g. ./camserver/demo_cam/include), and will use the numeric definitions found there.

Some rules apply:
the cases must occur in the same order as in your tvxcampkg.c
the comparison is case sensitive
the numeric values you assign must be monotonically increasing
the lowest value you assign should be larger than the largest automatic
     assignment - say, 200
there can be gaps in the numeric sequence reserved for future expansion
unassigned cases occuring after your assigned cases will be automatically
     assigned sequentially by the compiler after your last assigned case; 
     hence you need only assign the first case to obtain your own 
     private sequence
the numbers can be decimal or hex or octal
formatting can be with tabs or spaces
a '#' in the first column denotes a comment
leading tabs and trailing commas are ignored
cases listed in camserver_casedefs.txt, but not in tvxcampkg.c, are ignored, 
    but remain available for later use.

The easiest way to get your initial list of cases is to copy it out of
    camserver.h

The mechanism used here is completely general, and could be applied, in principle, to any program that uses mkheader.  But, tvx.c, e.g., makes use of the fact that the cases are sequential and numbered from 1, so test carefully.



----- CONTROLLING CAMSERVER WITH AN OUTSIDE CLIENT

The interface to camserver is very simple for an outside (i.e., not tvx) controlling client.  The client (e.g., a crystallography beam-line controlling program) attaches to the server after tvx is disconnected ('disconnect' command in tvx).  The client then issues:
    exptime <time>   --- needs to be done only once for a series of images
    exposure <pathname>  --- gives the full pathname for the image
    expend   --- end the exposure and write the image
The time requested in this method should be somewhat longer than that actually dictated by the client.  The requested time sets a time-out which will shut off the camera in the event of a hung client.

Tvx can continue to run in the disconnected state, and can be used to examine the images coming from the camera.  Tvx can also be reconnected after the outside client has connected, thereby making tvx a non-controlling client.  You can always type in the camserver window directly to control the server.

Of course, you need to write the code for interface.c to support your camera.  One area that needs attention is how to get headers (say, with crystallographic parameters) into the images.  One method is to have the client prewrite the header to disk under the name that the camera will use for the image, and then to have the camera concatenate the data with the header.



----- CAMSERVER COMMUNICATIONS PROTOCOL

The camserver socket communications are a very simple text-passing protocol.  Text messages sent to camserver on the socket are of exactly the same form as typed commands in the camserver window:

<command> [optional arguments]

These socket strings may be terminated by (null) or by \x18 (ascii 'can').  Strings may be concatenated using \n or \x18.

Probably the most interesting commands for most applications are:

imgpath <newpath>
exptime <time_in_s>
exposure <pathname>

If the full pathname to the image is given, then the 'imgpath' command is unnecessary.

Every command is acknowldeged on the socket by a response of the form:

<command> OK [message]\x18\0
   or
<command> ERR [message]\x18\0

The <command> here is the numeric value of the 'typedef enum' for the particular command as seen in tvx/camera/camserver/include/camserver.h.  In particular, the response to 'exposure' command has the value 7:

7 OK /home/det/p2_det/images/myfile.tif\x18\0

which comes after the exposure is complete.

Many commands are acknowldeged by a generic "Send" command, which has the value 15.  All commands are promptly acknowledged.  Exposure commands have a double acknowledge: the first is immediate and of the generic type.  The second is after the action is completed and carries the image name, or last image name in a series.

Probably the best strategy for a client program is to look for "OK" or "ERR"; otherwise it would be best to 'include "camserver.h"' to be sure that the case values are consistent.

If the 'config/camstat' directory is provided by the system, the full path name of the most recently completed image appears there in the file 'completed'.  If the user changes the image name with each exposure (a good idea), applications can tell where they are by monitoring that file.  If the user re-uses the same name repeatedly (e.g., 'temp.tif'), then the file modification time is the only clue as to when a new image is completed.  Note that in Linux the file modification time has a granularity of 1 second (depends on the file system), so monitoring 'completed' in the case of fast framing with a constant filename is not very informative.  Also note, that 'completed' is only a message from camserver that the file has been sent to the operating system; there is no way to know when the file is actually on disk, and for a very fully loaded system, this write back can be considerably delayed.  Thus, the users' application should monitor the 'size on disk' until it sees that the full file is there.  The function OpenDiskObject() in tvx/util/ipars.c (near line 2155) gives an example.

More recent versions of camserver first write <filename>.tmp, then rename it.  However, it is still possible for the file to be incomplete depending on the OS load.

