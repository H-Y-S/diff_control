/*****************************************************************************\
** slsp2det_cam.pkg - a package of version-specific hardware commands for    **
** PILATUS2 detectors.                                                       **
**                                                                           **
** Other parts of this package are:                                          **
**           ./progi2c - routines to program i2c components                  **
**           ../../slsp2det/slsp2det.pkg - commands for tvx                  **
**                                                                           **
**   The camserver header file, camserver.h, is included by camclient.c to   **
** give camclient access to the case names.  This brings case names here     **
** into conflict withg those in tvx.  Thus I use the rather strange          **
** orthography seen here, e.g. SeT and ProG, which have the identical        **
** meaning as Set and Prog in tvx, but must be declared differently.         **
**                                                                           **
**   To return a message to the client, the routines OK_response() and       **
** ERR_response() are provided.  The message is caught by camclient.c        **
** for printing on the tvx screen.  Messages can be addressed to any of      **
** handlers programmed in camclient.c:check_camera_response(), which are     **
** very few in number.  Thus,  ERR_response(CamCmd, "...") is a rather       **
** generic way to write a message on the tvx screen.  See 'LdCmdFile' or     **
** 'Exposure' for more specific applications.                                **
**                                                                           **
\*****************************************************************************/

	// set a dac or chsel
	case SeT:
		if ( check_permission(SeT) )
			break;
		if (*ptr == '\0')
			printf("Usage:\n\t set dac_name volts ..or\n\t set chsel_name\n");
		else
			{
			err=set_i2c(ptr);
#ifdef SLAVE_COMPUTER
			if (err == 3)	// not this computer
				{
				printf("    Not this computer\n");
				goto CommonCode;
				}
#endif
			if (err == 2)		// set bank and/or mod
				err = 0;		// not an error
			else if (err)
				{
				ERR_response(tx, CamCmd, "*** Error from pattern composer");
				err=0;			// done with err
				break;
				}
			else if (get_current_threshold() > 0.0)	// on success, invalidate threshold
				{
				set_current_threshold(0.0);
				printf(" >>> Threshold setting no longer valid\n");
				DBG(1, " >>> Threshold setting no longer valid\n");
				camera_record_variable(Cam_threshold_setting, "0");
				}
			goto CommonCode;
			}
		break;

	// reset chsel
	case Reset:
		if ( check_permission(Reset) )
			break;
		if (*ptr == '\0')
			printf("Usage:\n\t reset chsel_name\n");
		else
			{
			if ( (err=reset_i2c_chsel(ptr)) )
				{
				ERR_response(tx, CamCmd, "*** Error from pattern composer");
				err=0;			// done with err
				break;
				}
			strcpy(ptr, ptr+2);		// remove "re" from "reset"
			goto CommonCode;
			}
		break;		

	// program chsel with a pattern
	case ProG:
		if ( check_permission(ProG) )
			break;
		if (*ptr == '\0')
			printf("Usage:\n\t prog dac_name (or chsel) 0xnn\n");
		else
			{
			err=prog_i2c(ptr);
#ifdef SLAVE_COMPUTER
			if (err == 3)	// not this computer
				{
				printf("   Not this computer\n");
				goto CommonCode;
				}
#endif
			if (err)
				{
				ERR_response(tx, CamCmd, "*** Error from pattern composer");
				err=0;			// done with err
				break;
				}
			goto CommonCode;
			}
		break;

	CommonCode:
		OK_response(tx, Send, "");		// generic response
#ifdef MASTER_COMPUTER
//		if (selected_bank!=MAX_BANK_ADD && selected_bank>NDCB)
//			printf("    (Not this computer)\n");
#endif
		break;

	// show a DAC or CHSEL setting
	case Show:						// controlling process not required
		if (set_canonical_form(ptr))
			break;					// error - message already printed
		if ( (sp = getSetting(ptr)) )
			{
			if (sp->hadd.group == NOT_USED)
				{
				sprintf(line, "%s is not defined", ptr);
				printf("%s\n", line);
				OK_response(tx, CamCmd, line);
				}
			else if (sp->hadd.group == CHIPSEL && sp->hadd.output > 16)
				{
				sprintf(line, "%s pattern is set to 0x%x", ptr, sp->binv);
				printf("%s\n", line);
				OK_response(tx, CamCmd, line);
				}
			else if (sp->hadd.group == CHIPSEL)
				{
				sprintf(line, "%s is set to %d", ptr, sp->binv);
				printf("%s\n", line);
				OK_response(tx, CamCmd, line);
				}
			else
				{
				sprintf(line, "%s is set to %6.3fV", ptr, sp->vset);
				printf("%s\n", line);
				OK_response(tx, CamCmd, line);
				}
			}
		else
			{
			sprintf(line, "%s is not programmed", ptr);
			printf("%s\n", line);
			OK_response(tx, CamCmd, line);
			}
		break;

	// load settings from a file
	case Load:
		if ( check_permission(Load) )
			break;
		if (*ptr == '\0')
			printf("Usage:  Load filename\n");
		else
#ifdef MASTER_COMPUTER
			command_dispatcher(LdCmndFile, ptr, 0);
#else
			load_configuration(ptr);
#endif
		OK_response(tx, Send, "");		// generic response
		break;

	// save setting to a file
	case Save:
		if ( check_permission(Save) )
			break;
		if (*ptr == '\0')
			printf("Usage:\n\t Save filename\n");
		else
			save_configuration(ptr);
		OK_response(tx, Send, "");		// generic response
		break;

	// THread - read temperature and humidity
	// Usage: thread [channel]
	case THread:
		i=-1;
		flag=False;
		if (*ptr)
			i=atoi(ptr);
		if (i>=0)									// specific channel given
			{
			if ((t = dcb_read_temp(i)) <= -39.0)
#ifdef MASTER_COMPUTER
				sprintf(line, "Channel %d is not implmented on computer 0", i);
#else
				sprintf(line, "Channel %d is not implmented", i);
#endif
			else
				{
				sprintf(line, "Channel %d: Temperature = %.1lfC, Rel. Humidity = %.1lf%%",
						i, t, dcb_read_humidity(i));
				flag=True;
				}
			printf(" %s\n", line);
			}
		else
			{
			line[0]='\0';
			q=line;
			for(i=0;i<6*NDCB;i++)					// search for channels
				if ((t = dcb_read_temp(i)) >= 0.0)
					{
					if (flag)
						{
						strcat(line, ";\n");		// concatenate multiple channels for TX
						q = line+strlen(line);
						}
					sprintf(q, "Channel %d: Temperature = %.1lfC, Rel. Humidity = %.1lf%%",
							i, t, dcb_read_humidity(i));
					printf(" %s\n", q);
					flag = True;
					}
				else if (t >= -90.0)				// error on a previously logged channel
					{
					if (flag)
						{
						strcat(line, ";\n ");		// concatenate multiple channels for TX
						q = line+strlen(line);
						}
					sprintf(q, "Channel %d: Temperature = ERROR", i);
					printf(" %s\n", q);
					flag = True;
					}
			if (!flag)
				{
#ifdef MASTER_COMPUTER
				sprintf(line, "No T/H sensor found on computer 0");
#else
				sprintf(line, "No T/H sensor found");
#endif
				printf(" %s\n", line);
				}
			}
		if(flag)
			OK_response(tx, THread, line);				// specific response
		else
			ERR_response(tx, THread, line);
		break;

// **************************************************************************
//   End of commands with enum number fixed in include/camserver_casedefs.txt
// **************************************************************************

// --- inserted by Stefan Kohout on 3.10.2000
// --- Only a ".img" file - no text file
	case ImgonlY:
		if ( check_permission(ImgonlY) )
			break;
		// for sls P2 chip - everything is done in fifo.c
		if (strstr(ptr, "NUL"))		// nul, null, etc shuts off filesave
			strcpy(autofilename, "null");
		*imgfile = '\0';
		if (*ptr)
			{
			if ( (p=strchr(ptr, ' ')) )		// remove trailing blanks
				*p = '\0';
			if (*ptr == '~')
				{
				strcpy(imgfile, getenv("HOME"));
				strcat(imgfile, ptr+1);
				}
			else if ( strchr(ptr, '/') == NULL )	// no path - use default
				{
				strcpy(imgfile, cam_image_path);
				strcat(imgfile, ptr);
				}
			else if (*ptr == '.')
				{
				sprintf(line, "*** Illegal filename: %s", ptr);
				ERR_response(tx, Send, line);
				printf("  %s\n", line);
				break;
				}
			else
				strcpy(imgfile, ptr);		// path given
			}
		else		// no filename given - use auto
			{
			strcpy(imgfile, cam_image_path);
			strcat(imgfile, autofilename);		// make up a filename
			sprintf(imgfile+strlen(imgfile), "_%04d", filenumber);
			filenumber++;
			strcat(imgfile, ".tif");			// a default format
			printf("  %s\n", imgfile);
			}
		endTime = startTime+exposure_time;	// be nice to log file
		if (*imgfile)
			{
			dcb_start_read_image();			// set up a read
			camera_readout(imgfile, line);
			DBG(3, "Imgonly file name: %s\n", imgfile)
			if (!tx)
				printf("  Imgonly %s\n", imgfile);
			set_cam_stat(cam_completed, imgfile);
			}
		else
			printf("***Could not get the image file name\n");
		OK_response(tx, Send, imgfile);
		break;
// --- end of insertion by Stefan Kohout

	// enter the calpix mode - use Stop to end.  Usage: cpix [x y]
	case Cpix:
		if ( check_permission(Cpix) )
			break;
		col = row = 0;
		sscanf(ptr, "%d%d", &col, &row);
		px = pix_add(-1, col, row, -1, -1, -1, -1, -1, -1, -1, -1, -1);
		if (px->cx < 0)
			{
			printf("Pixel not in a chip\n");
			break;
			}
		// deselect all
		sprintf(line2, "B15_M07_CHSEL 0");
		prog_i2c(line2);
		sprintf(line2, "B%.2d_M%.2d_CHSEL%d", px->bn, px->mn, px->cn);
		set_i2c(line2);
		devno = dcb_get_gsdevno(px->bn, px->mn);
		dcb_reset_row_col(devno);
		dcb_insert_row_col_token(devno);
		for (i=0; i<px->cy; i++)
			dcb_advance_row_token(devno);
		for (i=0; i<px->cx; i++)
			dcb_advance_col_token(devno);
		dcb_start_calpix(devno);
		OK_response(tx, Send, "");		// generic response
		break;

	// enter the calpix_x mode (for x-rays)  Usage: cpix_x [x y]
	case Cpix_x:
		if ( check_permission(Cpix_x) )
			break;
		col = row = 0;
		sscanf(ptr, "%d%d", &col, &row);
		px = pix_add(-1, col, row, -1, -1, -1, -1, -1, -1, -1, -1, -1);
		if (px->cx < 0)
			{
			printf("Pixel not in a chip\n");
			break;
			}
		// deselect all
		sprintf(line2, "B15_M07_CHSEL 0");
		prog_i2c(line2);
		sprintf(line2, "B%.2d_M%.2d_CHSEL%d", px->bn, px->mn, px->cn);
		set_i2c(line2);
		devno = dcb_get_gsdevno(px->bn, px->mn);
		dcb_reset_row_col(devno);
		dcb_insert_row_col_token(devno);
		for (i=0; i<px->cy; i++)
			dcb_advance_row_token(devno);
		for (i=0; i<px->cx; i++)
			dcb_advance_col_token(devno);
		dcb_start_calpix_x(devno);
		OK_response(tx, Send, "");		// generic response
		break;

	// stop calpix or exposure
	case Stop:
		if ( check_permission(Stop) )
			break;
		printf("Stop DCB\n");
		dcb_stop();
		OK_response(tx, Send, "");		// generic response
		break;

	// Fillpix - fill all pixels of selected modules with a value
	// Usage:  fillpix [value [bank module]]
	case Fillpix:
		if ( check_permission(Fillpix) )
			break;
		value=0xfffff;
		bank = 15;				// default is select all
		mod = 7;
		while (*ptr=='0' && isdigit(*(ptr+1)))	// prevent octal conversion
			ptr++;
		sscanf(ptr, "%i%d%d", &value, &bank, &mod);
		dcb_set_bank_module_address(bank, mod);
		dcb_write_data_modpix(value);
		OK_response(tx, Send, "");		// generic response
		break;

	// SFillpix - slowly fill all pixels of selected modules with a value
	// Usage:  sfillpix [value [bank module]]
	case SFillpix:
		if ( check_permission(SFillpix) )
			break;
		value=0xfffff;
		bank = 15;				// default is select all
		mod = 7;
		while (*ptr=='0' && isdigit(*(ptr+1)))	// prevent octal conversion
			ptr++;
		sscanf(ptr, "%i%d%d", &value, &bank, &mod);
		dcb_set_bank_module_address(bank, mod);
		dcb_write_data_allpix_slow(value);
		OK_response(tx, Send, "");		// generic response
		break;

	// calibrate - send N calibrates to every pixel
	// Usage:  calibrate [N [bank module]]
	case Calibrate:
		if ( check_permission(Calibrate) )
			break;
		n = 100;				// default number of calibrates
		bank = 15;				// default is select all
		mod = 7;
		sscanf(ptr, "%d%d%d", &n, &bank, &mod);		
		dcb_set_bank_module_address(bank, mod);
		dcb_send_n_calibrates(n);
		OK_response(tx, Send, "");		// generic response
		break;


#ifdef SLSP2DET_CAMERA
	case Trim:			// trim x y value - set trim in 1 pixel or read-back setting
		// NB - bits are inverted: 0 means write all 1's, which turns off trim
		if ( check_permission(Trim) )
			break;
		row = col = value = -99;		// flag
		sscanf(ptr, "%d%d%i", &col, &row, &value);	// get parameters
		if (col == -1)				// reset selections
			{
			selected_bank = selected_mod = selected_chip = -1;
			break;
			}
		if (row == -99)
			{
			printf ("Usage: trim x y <value>\n");
			break;
			}
		if (selected_chip < 0)		// assume detector coordinates
			{
			if (row < 0 || row >= NROW_DET)
				{
				printf("Detector row out of bounds: %d\n", row);
				break;
				}
			if (col < 0 || col >= NCOL_DET)
				{
				printf("Detector column out of bounds: %d\n", col);
				break;
				}
			}
		else				// assume chip coordinates
			{
			if (row < 0 || row >= NROW_CHIP)
				{
				printf("Chip row out of bounds: %d\n", row);
				break;
				}
			if (col < 0 || col >= NCOL_CHIP)
				{
				printf("Chip column out of bounds: %d\n", col);
				break;
				}
			}
		if (value == -99)	// no value asks for current setting
			{
			// slsp2det: trimValues[NBANK][NMOD_BANK][NCHIP][NROW_CHIP][NCOL_CHIP]
			if (selected_chip < 0)	// assume detector coordinates
				{
				px = pix_add(-1, col, row, -1, -1, -1, -1, -1, -1, -1, -1, -1);
				if (px->cx < 0)
					{
					printf("Pixel not in a chip\n");
					break;
					}
				if (trimValues[px->bn-1][px->mn-1][px->cn][px->cy][px->cx] == -1)
					printf("Trim: bank = %d, mod = %d, ch = %d, cx = %d, cy = %d is not set\n", 
							px->bn, px->mn, px->cn, px->cx, px->cy);
				else
					printf("Trim: bank = %d, mod = %d, ch = %d, cx = %d, cy = %d set to: %d\n",
							px->bn, px->mn, px->cn, px->cx, px->cy, 
							trimValues[px->bn-1][px->mn-1][px->cn][px->cy][px->cx]);
				}
			else if (selected_bank>0 && selected_mod>0)		// assume chip coordinates
				{
				if (trimValues[selected_bank-1][selected_mod-1][selected_chip][row][col] == -1)
					printf("Trim: bank = %d, mod = %d, ch = %d, x = %d, y = %d is not set\n", 
							selected_bank, selected_mod, selected_chip, col, row);
				else
					printf("Trim: bank = %d, mod = %d, ch = %d, cx = %d, cy = %d set to: %d\n",
							selected_bank, selected_mod, selected_chip, col, row, 
							trimValues[selected_bank-1][selected_mod-1][selected_chip][row][col]);
				}
			else
				{
				printf("Exactly 1 chip must be selected\n");
				ERR_response(tx, CamCmd, "Exactly 1 chip must be selected");
				}
			break;
			}
		// from here, 'tis a trim command to a chip
		if (NBANK*NMOD_BANK==1)		// relax single module requirements
			{
			selected_bank = 1;
			selected_mod = 1;
			}
		if (selected_chip<0 || selected_mod<=0 || selected_bank<=0 ||
				selected_chip>=NCHIP || selected_bank>NBANK || selected_mod>NMOD_BANK)
			{
			printf("Exactly 1 chip must be selected for trim command\n");
			ERR_response(tx, CamCmd, "Exactly 1 chip must be selected");
			break;
			}
		if (value < 0 || value > MAX_TRIM_VALUE)
			{
			printf("Trim value out of bounds: %d\n", value);
			break;
			}
			// put the value into the array
		trimValues[selected_bank-1][selected_mod-1][selected_chip][row][col] = value;
		trimallVal = -1;		// signal that not all trims are the same
			// if we are loading from a file, we're done
		if (loadingTrimFile)
			break;
		setTrims();		// load trim bits into all pixels
		OK_response(tx, CamCmd, "");
		trim_directory[0] = '\0';
		break;
#else
	case Trim:
		printf("Trim for slsp2_1c_cam is not implemented\n");
		break;
#endif		// SLSP2DET_CAMERA

	case Trim_all:		// trim_all value - set all pixels to same trim
		// NB - bits are inverted: 0 means write all 1's, which turns off trim
		if ( check_permission(Trim_all) )
			break;
		while (*ptr=='0' && isdigit(*(ptr+1)))	// prevent octal conversion
			ptr++;
		sscanf(ptr, "%i", &value);		// get the trim value
		if (value < 0 || value > MAX_TRIM_VALUE)
			{
			printf("Trim value out of bounds: %d\n", value);
			break;
			}
		init_trim_array(value);	// record the "individual" values
		trimallVal = value;		// signal that trims are all the same
		dcb_trim_allpix(value);
		OK_response(tx, CamCmd, "");
		trim_directory[0] = '\0';
		if (get_current_threshold() > 0.0)	// invalidate threshold
			{
			set_current_threshold(0.0);
			printf(" >>> Threshold setting no longer valid\n");
			DBG(1, " >>> Threshold setting no longer valid\n");
			camera_record_variable(Cam_threshold_setting, "0");
			}
		break;

	case SetTrims:			// set trims from stored array
		if ( check_permission(SetTrims) )
			break;
		setTrims();					// (re)set trims from array - in settrims.c
		OK_response(tx, CamCmd, "");
		if (get_current_threshold() > 0.0)	// invalidate threshold
			{
			set_current_threshold(0.0);
			printf(" >>> Threshold setting no longer valid\n");
			DBG(1, " >>> Threshold setting no longer valid\n");
			camera_record_variable(Cam_threshold_setting, "0");
			}
		break;

	case TrimFromFile:			// load trims from a file
		if ( check_permission(TrimFromFile) )
			break;
		if (*ptr)			// remember trimFileName as default
			{
			if (*ptr == '/')					// if path is given
				strcpy(trimFileName, ptr);
			else if (*ptr == '~')
				{
				strcpy(trimFileName, getenv("HOME"));
				strcat(trimFileName, ptr+1);
				}
			else								// make up full path
				{
				strcpy(trimFileName, cam_data_path);
				strcat(trimFileName, ptr);
				}
			}
		if (*trimFileName == '\0')
			{
			printf("Need a file name\n");
			break;
			}
		strcpy(trim_directory, trimFileName);
		if ( (q = strrchr(trim_directory, '/')) )
			*q = '\0';
		loadingTrimFile = True;
		command_dispatcher(LdCmndFile, trimFileName, 0);
		loadingTrimFile = False;	// finished loading trims
					// the command 'settrims' should be in the file
		trimallVal = -1;			// signal that not all trims are the same
		OK_response(tx, CamCmd, "");
		break;

	case LogImgFile:		// log last image parameters to 'params.txt' file
		if ( check_permission(LogImgFile) )
			break;
		for(bank=1; bank<=NBANK; bank++)
			{
			for(mod=1; mod<=NMOD_BANK; mod++)
				{
				sprintf(line, "B%d_M%d", bank, mod);
				set_canonical_form(line);	// set default bank & mod as applicable
				p = line2;					// make up text here
				*p = '\0';
				strcpy(line, "VCAL");
				if (set_canonical_form(line))
					break;					// error - message already printed
				if ( (sp = getSetting(line)) )
					{
					vcal = sp->vset;
					sprintf(p, "%6.3f    ", vcal);
					}
				else
					{
					vcal = 0.0;
					strcat(p, "   ??    ");
					}
				p += strlen(p);
											// value of VRF
				get_vrfall(line, bank, mod);
				strcat(p, line);
				p += strlen(p);
											// value of VRFS
				get_vrfsall(line, bank, mod);
				strcat(p, line);
				p += strlen(p);
											// value of VTRM
				get_vtrmall(line, bank, mod);
				strcat(p, line);
				p += strlen(p);
											// value of VCMP
				get_vcmpall(line, bank, mod);
				strcat(p, line);
				p += strlen(p);
											// TRIM value or filename from last trim
				if (trimallVal < 0)			// trims not all the same - use filename
					{
					if ( strrchr(trimFileName, '/') )
						{					// if it was an autotrim file, make up name
						strcpy(line, ".");
						strcat(line, strrchr(trimFileName, '/'));
						if ( (cP=strstr(line, "autotrim")) )
							{
							*(cP+strlen("autotrim")) = '\0';
							moduleFilename(line, NULL, "", bank, mod);
							}
						strcat(p, line);
						strcat(p, "  ");
						}
					else
						strcat(p, "  * ");		// no info on trim file name
					}
				else						// uniform trim value
					sprintf(p, "%4d ", trimallVal);
				p += strlen(p);
											// the image filename - relative to here
				strcpy(line, "  .");
				strcat(line, strrchr(imgfile, '/'));
				strcat(p, line);
				strcat(p, "\n");
											// append to image params file in same directory
				strcpy(line, imgfile);
				*(1+strrchr(line, '/')) = '\0';
				moduleFilename(line, NULL, "params.txt", bank, mod);
				DBG(3, "LogImgFile - appending to %s\n", line)
				if ( (ofp=fopen(line, "a")) == NULL)
					{
					printf("Unable to open %s for writing\n", line);
					break;
					}
				fputs(line2, ofp);
				fclose(ofp);
				}
			}
		OK_response(tx, Send, line);		// generic response
		break;

	case Read_signals:			// re-read signal definitions
		if ( check_permission(Read_signals) )
			break;
		if (*ptr)
			read_detector_info(ptr);
		else
			printf("File name required\n");
		OK_response(tx, Send, "");		// generic response
		break;

	case LogSettings:			// log i2c settings to treport.txt
		if ( check_permission(LogSettings) )
			break;
		strcpy(line, cam_image_path);
		strcat(line, ptr);
		if (*(line+strlen(line)-1) != '/')
			strcat(line, "/");
		strcat(line, "treport.txt");
		if ( (ofp = fopen(line, "a")) == NULL)
			{
			printf("LogSettings - Could not open file for appending:\n\t%s\n",
				line);
			break;
			}
		else
			{
			printf("LogSettings from stored values to:\n");
			printf("\t%s\n", line);
			DBG(3, "LogSettings to %s\n", line)
			*(1+strrchr(line, '/')) = '\0';		// isolate path
			// log settings to treport.txt and make setdacs.dat
			log_i2c_settings(ofp, line);
			log_gpib_readings(ofp);
			fclose(ofp);
			}
		OK_response(tx, Send, line);		// generic response
		break;

	case ImgMode:		// x-rays vs. pulses
		if (NCHIP == 1)			// only 1 chip in system
			{
			printf("Only 1 chip declared - img_mode is pulses\n");
			break;
			}
		else if (*ptr == '\0')
			{
			if (img_mode)
				strcpy(line, "ImgMode is x-rays");
			else
				strcpy(line, "ImgMode is pulses");
			printf(" %s\n", line);
			OK_response(tx, Send, line);		// generic response
			break;
			}		
		if ( check_permission(ImgMode) )
			break;
		line[0]='\0';
		if (*ptr == 'X' || *ptr == 'x' || *ptr == '1' )
			{
			img_mode = 1;
			xor_tab_initialize(-1);
			camera_record_variable(Cam_image_mode, "1");
			}
		else if (*ptr == 'P' || *ptr == 'p' || *ptr == '0' )
			{
			if (tau > 0.0)
				strcat(line, "Turning off rate correction  ");
			if (nfrmpim > 1)
				strcat(line, "Turning off multi-frame images  ");
			if (gap_fill_byte)
				{
				strcat(line, "Setting gap-fill byte to 0");
				gap_fill_byte=0;
				initialize_theImage(0);
				}
			tau = 0.0;
			img_mode = 0;
			nfrmpim = 1;
			i = 1;
			dcb_set_tx_frame_limit(i);
			n_images = i;
//			sprintf(line, "%d", i);
//			camera_record_variable(Cam_NImages, line);
			xor_tab_initialize(-1);
			camera_record_variable(Cam_image_mode, "0");
			camera_record_variable(Cam_tau, "0");
//			camera_record_variable(Cam_NFrameImg, "1");
			}
		OK_response(tx, Send, line);		// generic response
		if(line[0])
			printf(" %s\n", line);
		break;

#ifdef USE_GPIB
	case Gpibsend_volt:
		if ( check_permission(Gpibsend_volt) )
			break;
		gpibsend_vo(ptr);
		OK_response(tx, Send, "");		// generic response
		break;

	case Gpibread_volt:
		gpibread_vo();
		OK_response(tx, Send, "");		// generic response
		break;

	case Gpibread_scope:
		gpibread_os(ptr);
		OK_response(tx, Send, "");		// generic response
		break;

	case Gpibsend_scope:
		if ( check_permission(Gpibsend_scope) )
			break;
		gpibsend_os(ptr);
		OK_response(tx, Send, "");		// generic response
		break;
	
	case Scopeimg:
		if ( check_permission(Scopeimg) )
			break;
		imgfile[0]='\0';
		if (*ptr!='/')
			strcpy(imgfile, cam_image_path);
		strcat(imgfile, ptr);
		if ((ofd = open(imgfile, O_WRONLY | O_CREAT | O_TRUNC,
					S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH)) == -1)
			{
			printf("Could not open %s for writing\n", imgfile);
			break;
			}
		truncate_image(theImage, NCOL_CHIP*NROW_CHIP);		// in-place 32 to 16 bit
		write(ofd, theImage, NCOL_CHIP*NROW_CHIP*sizeof(unsigned short));
		close(ofd);
		printf("Writing: %s\n", imgfile);
		memset(theImage, 0, NCOL_CHIP*NROW_CHIP*sizeof(TYPEOF_PIX));
		OK_response(tx, Send, "");		// generic response
		break;
#else
//	case Gpibsend_volt:
//	case Gpibsend_scope:
//	case Gpibread_volt:
//	case Gpibread_scope:
//	case Scopeimg:
//		printf("GPIB operations not enabled\n");
//		break;
#endif		// USE_GPIB

	// set or query the number of (accumulated) exposures per frame
	case NExpFrame:
		if (*ptr == '\0')
			{
			ui = dcb_get_exposure_count_limit();		// read firmware
			sprintf(line, "Exposures per frame set to: %u", ui);
			printf(" %s\n", line);
			OK_response(tx, Send, line);
			break;
			}
		if ( check_permission(NExpFrame) )
			break;
		sscanf(ptr, "%d", &ui);
		if (ui<1)
			ui=1;
		if (dcb_set_exposure_count_limit(ui))
			{
			sprintf(line, "Error: NExpFrame (%u) too large", ui);
			printf(" %s\n", line);
			ERR_response(tx, Send, line);
			break;
			}
//		sprintf(line, "%u", ui);
//		camera_record_variable(Cam_NExpFrame, line);
		sprintf(line, "Exposures per frame set to: %u", ui);
	//	if (tx)
			printf("  %s\n", line);
		OK_response(tx, Send, line);
		break;

	// set or query the number of frames to be summed to an image
	case NFrameImg:
		if (*ptr == '\0')
			{
			sprintf(line, "Frames per image set to: %d", nfrmpim);
			printf(" %s\n", line);
			OK_response(tx, Send, line);
			break;
			}
		if ( check_permission(NFrameImg) )
			break;
		sscanf(ptr, "%d", &nfrmpim);
		if (nfrmpim<1)
			nfrmpim=1;
//		sprintf(line, "%d", nfrmpim);
//		camera_record_variable(Cam_NFrameImg, line);
		sprintf(line, "Frames per image set to: %d", nfrmpim);
	//	if (tx)
			printf("  %s\n", line);
		OK_response(tx, Send, line);
		break;

	// set or query the total number of images to make
	case NImages:
		if (*ptr == '\0')
			{
			i = dcb_get_tx_frame_limit();		// read firmware
			sprintf(line, "N images set to: %d", i );
			printf("  %s\n", line);
			OK_response(tx, Send, line);
			break;
			}
		if ( check_permission(NImages) )
			break;
		i = atoi(ptr);
		if (i<1)
			i=1;
		dcb_set_tx_frame_limit(i);
		n_images = i;
//		sprintf(line, "%d", i);
//		camera_record_variable(Cam_NImages, line);
		sprintf(line, "N images set to: %d", i );
	//	if (tx)
			printf("  %s\n", line);
		OK_response(tx, Send, line);
		break;

	// set the exposure period for high speed framing, in sec.
	case ExpPeriod:
		if (*ptr == '\0')
			{
			v = dcb_get_exposure_period();		// read firmware
			sprintf(line, "Exposure period set to: %.6f sec", v);
			printf(" %s\n", line);
			OK_response(tx, Send, line);
			break;
			}
		if ( check_permission(ExpPeriod) )
			break;
		sscanf(ptr, "%lf", &v);
		if (v < 0.0)
			{
			sprintf(line, "Illegal exposure period\n");
			printf("%s\n", line);
			ERR_response(tx, Send, line);
			break;
			}
		sprintf(line, "%.6f", v);
//		camera_record_variable(Cam_ExpPeriod, line);
		dcb_set_exposure_period(v);
		sprintf(line, "Exposure period set to: %.6f sec", v);
	//	if (tx)
			printf("  %s\n", line);
		OK_response(tx, Send, line);
		break;

	// ExtEnable - make 'NImages' exposures using an external gate for ENB
	// usage:  extenable file_base_name
	case ExtEnable:
		if ( check_permission(ExtEnable) )
			break;
		if (*ptr == '\0')
			{
			printf("No image file specified\n");
			break;
			}
		if (*ptr == '/')				// full path given
			image_file[0] = '\0';
		else
			strcpy(image_file, cam_image_path);
		strcat(image_file, ptr);
		camera_check_priority();
		printf(" Preparing camera for exposure\n");
		set_cam_stat(cam_target, image_file);
		set_cam_stat(cam_state, "preparing");
		Cam_State = CamPreparing;
//		dcb_set_exposure_period(1.0);
		if ( camera_prepare(&exposure_time) )
			{
			set_cam_stat(cam_state, "idle");
			Cam_State = CamIdle;
			ERR_response(tx, Exposure, image_file);
			break;
			}
		sprintf(line ,"Starting externally enabled exposure(s): %s",
				timestamp());
		if (tx)
			printf(" %s\n", line);
		OK_response(tx, Send, line);		// send to client
		external_enable_mode=1;
		gettimeofday(&tv, 0);
		startTime = lastTime = (double)tv.tv_sec + (double)tv.tv_usec/1e6;
		endTime = lastTime + exposure_time;
		sprintf(line, "%.6lf", exposure_time);
		set_cam_stat(cam_time, line);
		timerRunning = True;
		set_cam_stat(cam_state, "exposing");
		txImage = tx;							// flag for end_exposure()
		Cam_State = CamExposing;
		if ( camera_start(&exposure_time) )
			{
			camera_stop(2);
			shutter_on_off(0);
			set_cam_stat(cam_state, "idle");
			Cam_State = CamIdle;
			timerRunning = False;
			ERR_response(tx, Exposure, image_file);
			}
		break;

	// ExtTrigger - make 'NImages' exposures using an external trigger
	// usage:  exttrigger file_base_name
	case ExtTrigger:
		if ( check_permission(ExtTrigger) )
			break;
		if (*ptr == '\0')
			{
			printf("No image file specified\n");
			break;
			}
		if (*ptr == '/')				// full path given
			image_file[0] = '\0';
		else
			strcpy(image_file, cam_image_path);
		strcat(image_file, ptr);
		printf(" Preparing camera for exposure\n");
		set_cam_stat(cam_target, image_file);
		set_cam_stat(cam_state, "preparing");
		Cam_State = CamPreparing;
		if ( camera_prepare(&exposure_time) )
			{
			set_cam_stat(cam_state, "idle");
			Cam_State = CamIdle;
			ERR_response(tx, Exposure, image_file);
			break;
			}
		sprintf(line ,"Starting externally triggered exposure(s): %s",
				timestamp());
		if (tx)
			printf(" %s\n", line);
		OK_response(tx, Send, line);		// send to client
		external_trigger_mode=1;
		gettimeofday(&tv, 0);
		startTime = lastTime = (double)tv.tv_sec + (double)tv.tv_usec/1e6;
		endTime = lastTime + exposure_time;
		sprintf(line, "%.6lf", exposure_time);
		set_cam_stat(cam_time, line);
		timerRunning = True;
		set_cam_stat(cam_state, "exposing");
		txImage = tx;							// flag for end_exposure()
		Cam_State = CamExposing;
		if ( camera_start(&exposure_time) )
			{
			camera_stop(2);
			shutter_on_off(0);
			set_cam_stat(cam_state, "idle");
			Cam_State = CamIdle;
			timerRunning = False;
			ERR_response(tx, Exposure, image_file);
			}
		break;

	// ExtMTrigger - make 'NImages' exposures using multiple external triggers
	// usage:  exttrigger file_base_name
	case ExtMTrigger:
		if ( check_permission(ExtMTrigger) )
			break;
		if (*ptr == '\0')
			{
			printf("No image file specified\n");
			break;
			}
		if (*ptr == '/')				// full path given
			image_file[0] = '\0';
		else
			strcpy(image_file, cam_image_path);
		strcat(image_file, ptr);
		printf(" Preparing camera for exposure\n");
		set_cam_stat(cam_target, image_file);
		set_cam_stat(cam_state, "preparing");
		Cam_State = CamPreparing;
		if ( camera_prepare(&exposure_time) )
			{
			set_cam_stat(cam_state, "idle");
			Cam_State = CamIdle;
			ERR_response(tx, Exposure, image_file);
			break;
			}
		sprintf(line ,"Starting externally multi-triggered exposure(s): %s",
				timestamp());
		if (tx)
			printf(" %s\n", line);
		OK_response(tx, Send, line);		// send to client
		external_multi_trigger_mode=1;
//		dcb_set_exposure_period(exposure_time+0.005);	// not used
		gettimeofday(&tv, 0);
		startTime = lastTime = (double)tv.tv_sec + (double)tv.tv_usec/1e6;
		endTime = lastTime + exposure_time;
		sprintf(line, "%.6lf", exposure_time);
		set_cam_stat(cam_time, line);
		timerRunning = True;
		set_cam_stat(cam_state, "exposing");
		txImage = tx;							// flag for end_exposure()
		Cam_State = CamExposing;
		if ( camera_start(&exposure_time) )
			{
			camera_stop(2);
			shutter_on_off(0);
			set_cam_stat(cam_state, "idle");
			Cam_State = CamIdle;
			timerRunning = False;
			ERR_response(tx, Exposure, image_file);
			}
		break;

	// Delay - set the delay for the external trigger mode of exposures
	// usage:  delay [time_in_seconds [dcb_no]]
	case Delay:
		if (*ptr == '\0')					// report current settings
			{
			if (trigger_offset[0] < 0.0 || DET_NDCB==1)
				{
				v = dcb_get_exp_trigger_delay(-1);	// read firmware
				sprintf(line, "Delay time set to: %.6f sec.", v);
				}
			else
				{
				line[0] = '\0';
				for (i=0; i<DET_NDCB; i++)
					{
					sprintf(line2, "DCB %d delay time set to: %.6lf sec.",
						i, trigger_offset[i]);
					printf(" %s\n", line2);
					strcat(line, line2);
					strcat(line, "\n");
					}
				*strrchr(line, '\n') = '\0';
				}
			printf(" %s\n", line);
			OK_response(tx, Send, line);
			break;
			}
		if ( check_permission(Delay) )
			break;
		n = -1;
		sscanf(ptr, "%lf%d", &v, &n);
		if (n < 0 || DET_NDCB==1)					// normal case
			{
			if (dcb_set_exp_trigger_delay(v, -1))
				{
				sprintf(line, "Illegal delay time: %lf", v);
				printf(" %s\n", line);
				ERR_response(tx, Send, line);
				break;
				}
			for (i=0; i<DET_NDCB; i++)
				trigger_offset[i] = -1;
			sprintf(line, "Delay time set to: %.6lf sec", v);
			printf("  %s\n", line);
			OK_response(tx, Send, line);		// generic response
			}
		else
			{
#if defined SLAVE_COMPUTER
			n -= 1 + NDCB*(1-SLAVE_COMPUTER);
			if (n < 0 || n > DET_NDCB)
				{
				printf(" Not this computer\n");
				OK_response(tx, Send, "");		// generic response
				break;
				}
#endif
			if (n < 0 || n > DET_NDCB)
				{
				sprintf(line, "*** Illegal dcb number: %d\n", n);
				printf(" %s\n", line);
				ERR_response(tx, Send, line);
				break;
				}
			for (i=0; i<n; i++)
				if (trigger_offset[i] < 0)
					trigger_offset[i] = 0.0;
			trigger_offset[n] = v;
			for (i=n; i<DET_NDCB; i++)
				if (trigger_offset[i] < 0)
					trigger_offset[i] = v;
#if defined MASTER_COMPUTER
			if (n >= NDCB)
				{
				printf(" Not this computer\n");
				OK_response(tx, Send, "");		// generic response
				break;
				}
#endif
			if (dcb_set_exp_trigger_delay(v, n))
				{
				sprintf(line, "*** Illegal delay time: %lf", v);
				printf(" %s\n", line);
				ERR_response(tx, Send, line);
				break;
				}
			sprintf(line, "DCB %d delay time set to: %.6lf sec", n, v);
			printf("  %s\n", line);
			OK_response(tx, Send, line);		// generic response
			}
		break;

	// DebTime - set or read the debounce time for external enable mode
	// Usage:  debtime [t]
	case DebTime:
		if (*ptr == '\0')
			{
			v = dcb_get_debounce_time();	// read firmware
			sprintf(line, "Debounce time set to: %.6lf sec.", v);
			printf(" %s\n", line);
			OK_response(tx, Send, line);
			break;
			}
		if ( check_permission(DebTime) )
			break;
		sscanf(ptr, "%lf", &v);
		if (dcb_set_debounce_time(v))
			{
			sprintf(line, "Illegal debounce time: %lf sec", v);
			printf("%s\n", line);
			ERR_response(tx, Send, line);
			break;
			}
		sprintf(line, "Debounce time set to: %.6lf sec", v);
		if (tx)
			printf(" %s\n", line);
		OK_response(tx, Send, line);		// generic response
		break;

	// DataSection - write a DataSection identifier line to all param files
	// using the path of the last image file
	// usage:  datasection any_text
	case DataSection:
		if ( check_permission(DataSection) )
			break;
		if (!imgfile[0])
			{
			printf("***Can't find image name for path\n");
			break;
			}
		strcpy(line2, "# DataSection ");
		if (*ptr == '\0')
			{
			printf("A name for DataSection is required\n");
			break;
			}
		strcat(line2, ptr);
		strcat(line2, "\n");
		for(bank=1; bank<=NBANK; bank++)
			{
			for(mod=1; mod<=NMOD_BANK; mod++)
				{
				strcpy(line, imgfile);	// append to params files in same directory
				*(1+strrchr(line, '/')) = '\0';
				moduleFilename(line, NULL, "params.txt", bank, mod);
				DBG(3, "DataSection - appending to %s\n", line)
				if ( (ofp=fopen(line, "a")) == NULL)
					{
					printf("Unable to open %s for writing\n", line);
					break;
					}
				fputs(line2, ofp);
				fclose(ofp);
				}
			}
		*(1+strrchr(line, '/')) = '\0';
		if (tx)
			printf(" DataSection directory: %s\n", line);
		OK_response(tx, Send, "");		// generic response
		break;

	// VDelta - apply a voltage increment to signals in all modules
	// usage:  vdelta signal_base_name delta
	case VDelta:
		if ( check_permission(VDelta) )
			break;
		apply_deltaV(ptr);
		OK_response(tx, Send, "");		// generic response
		break;

	// Tau - control in-line rate correction
	// usage:  tau [value_in_s]
	case Tau:
		if (*ptr == '\0')
			{
			if (tau == 0.0)
				sprintf(line, "Rate correction is off, cutoff = %d counts", count_cutoff);
			else
				sprintf(line, "Rate correction is on; tau = %.1lfe-9 s, cutoff = %d counts",
						1.0e9*tau, count_cutoff);
			printf(" %s\n", line);
			OK_response(tx, Send, line);
			break;
			}
		if ( check_permission(Tau) )
			break;
		v = -1.0;
		v = atof(ptr);
		if (v < 0.0 || v > 1000.0e-9)
			{
			sprintf(line, "Invalid argument; %lf", v);
			printf(" %s\n", line);
			ERR_response(tx, Send, line);
			break;
			}
		else if (v == tau)					// nothing to do
			{
			OK_response(tx, Send, "");		// generic response
			break;
			}
		else if (v == 0.0)	// turn off rate correction
			{
			img_mode = 1;
			tau = 0.0;
			strcpy(line, "Turn off rate correction");
			camera_record_variable(Cam_tau, "0.0");
			xor_tab_initialize(-1);		// in case rate correction parameters have changed
			}
		else		// new value of tau
			{
			img_mode = 1;
			tau = v;
			sprintf(line, "%.1lfe-9", 1.0e9*tau);
			camera_record_variable(Cam_tau, line);
			sprintf(line, "Set up rate correction: tau = %.1lfe-9 s", 1.0e9*tau);
			xor_tab_initialize(-1);		// in case rate correction parameters have changed
			}
		printf(" %s\n", line);
		OK_response(tx, Send, line);		// generic response
		break;

	// SensorHtr - turn on/off the sensor heater.
	// Usage:  sensorhtr [channel] [on]
	case SensorHtr:
		if ( check_permission(SensorHtr) )
			break;
		if (isdigit(*ptr))		// pick up channel number
			{
			i=atoi(ptr);
			while (isdigit(*ptr) || isspace(*ptr))
				ptr++;
			}
		else
			i=0;				//default channel
		if (!*ptr)		// just query state
			{
			n = dcb_sensor_heater_control(i, -1);
			if (n<0)
				break;		// error message already printed
			if (n)
				sprintf(line, "Sensor heater for channel %d is ON", i);
			else
				sprintf(line, "Sensor heater for channel %d is OFF", i);
			printf("%s\n", line);
			OK_response(tx, Send, line);		// generic response
			break;
			}
		if ( check_permission(SensorHtr) )
			break;
		n = dcb_sensor_heater_control(i, (!strncasecmp(ptr, "on", 2)) );
		if (n<0)
			break;		// error message already printed
		if (n)
			sprintf(line, "Sensor heater for channel %d is ON", i);
		else
			sprintf(line, "Sensor heater for channel %d is OFF", i);
		printf(" %s\n", line);
		OK_response(tx, Send, line);		// generic response
		break;

	// SetLimTH - query or set temp / humidity alarm limits
	// Usage:  setlimth [chan [Tlo Thi Hlo Hhi]]
	case SetLimTH:
		if (*ptr == '\0')
			{
			flag=1;
			for(chan=0; chan<6*NDCB; chan++)
				{
				thi = dcb_read_temp_high_limit(chan);
				if (thi < 0.0)
					continue;
				hhi = dcb_read_humidity_high_limit(chan);
				tlo = dcb_read_temp_low_limit(chan);
				hlo = dcb_read_humidity_low_limit(chan);
				if (flag)				// print headings
					{
					n=0;
					n += sprintf(line+n, " chan  Tlo   Thi   Hlo   Hhi\n");
					flag=0;
					}
				n += sprintf(line+n, " %d   %.1lf  %.1lf  %.1lf  %.1lf\n", 
						chan, tlo, thi, hlo, hhi);
				}
			printf("%s\n", line);
			OK_response(tx, Send, line);
			break;
			}
		if ( check_permission(SetLimTH) )
			break;
		chan=-1;		// defaults & flag
		tlo=18.0;
		thi=40.0;
		hlo=0.0;
		hhi=50.0;
		sscanf(ptr, "%d%lf%lf%lf%lf", &chan, &tlo, &thi, &hlo, &hhi);
		if (chan < 0)
			{
			strcpy(line, "Usage: setlimth [chan [Tlo Thi Hlo Hhi]]");
			printf(" %s\n", line);
			ERR_response(tx, Send, line);
			}
		n=0;
		n+=dcb_set_temp_low_limit(chan, tlo);
		n+=dcb_set_temp_high_limit(chan, thi);
		n+=dcb_set_humidity_low_limit(chan, hlo);
		n+=dcb_set_humidity_high_limit(chan, hhi);
		if (n)
			{
			strcpy(line, "*** Error(s) while setting temp / humidity limits");
			printf(" %s\n", line);
			ERR_response(tx, Send, line);
			}
		else
			OK_response(tx, Send, "");
		break;

	// Software set sampling delay on the dcb/bcb
	// Usasge:  setsdelay n  (0 <= n <= 0xff)
	case SetSDelay:
		i=-1;
		sscanf(ptr, "%i", &i);
		if (i<0)
			{
			dcb_set_bank_module_address(1, 1);		// select one
			sprintf(line, "Sample delay setting is: 0x%x\n", dcb_get_delay_setting(0));
			printf(" %s\n", line);
			OK_response(tx, Send, line);		// generic response
			break;
			}
		if ( check_permission(SetSDelay) )
			break;
		dcb_set_delay_setting_all(i);
		dcb_set_bank_module_address(1, 1);			// select one
		sprintf(line, "Sample delay set to: 0x%x", dcb_get_delay_setting(0));
		if (tx)
			printf(" %s\n", line);
		OK_response(tx, Send, line);		// generic response
		break;

	// BitMode - set the readout dynamic range to 4, 8 or 20 bits
	// Usage:  bitmode [n]
	case BitMode:
		if (*ptr == '\0')
			{
			printf("Readout dynamic range is: %d bits\n", dcb_get_readout_bits());
			break;
			}		
		if ( check_permission(BitMode) )
			break;
		i = atoi(ptr);
		if (i!=4 && i!=8)
			i=20;
		dcb_set_readout_bits(i);
		sprintf(line, "Readout dynamic range is: %d bits", dcb_get_readout_bits());
		printf(" %s\n", line);
		OK_response(tx, Send, line);		// generic response
		break;
	
	// Dcb_init - full initialize of the DCB
	// Usage:  dcb_init
	case Dcb_init:
		if ( check_permission(Dcb_init) )
			break;
		if (dcb_initialize(camera_name))
			strcpy(line, "Bad return from dcb_initialize()");
		else
			strcpy(line, "OK return from dcb_initialize()");
		if (tx)
			printf("%s\n", line);
		// reread the startup file to set the dacs
		if ( cam_startup_file[0] )
			{
			if ( ((fp = fopen(cam_startup_file, "r")) !=NULL) )
				{
				printf("... Reading camera startup file:\n");
				printf("   %s\n", cam_startup_file);
				DBG(1, "Reading camera startup file: %s\n", cam_startup_file)
				while (fgets(line, sizeof(line), fp) != NULL)
					{
					printf("%s", line);
					if (line[0] == '#')		// permit comments
						continue;
					command_interpreter(line, False);
					}
				fclose(fp);
				}
			else
				{
				printf("*** Could not find camera startup file: \n");
				printf("    %s\n", cam_startup_file);
				}
			}
		OK_response(tx, Send, line);		// generic response
		break;

	// GapFill - query or set the value to fill in gaps in the detector
	// Usage:  gapfill [n]
	case GapFill:
#ifdef SLSP2_1M_CAMERA
		strcpy(line, "Not applicable to single module detectors");
		ERR_response(tx, Send, line);
		printf(" %s\n", line);
		break;				// no-op for single modules	
#endif
		if (*ptr == '\0')
			{
			sprintf(line, "Detector gap-fill is: %d", gap_fill_byte);
			printf("%s\n", line);
			OK_response(tx, Send, line);		// generic response
			break;
			}		
		if ( check_permission(GapFill) )
			break;
		i = atoi(ptr);
		if (i!=0 && i!=-1)
			{
			sprintf(line, "Illegal value for gap-fill");
			printf("%s\n", line);
			OK_response(tx, Send, line);		// generic response
			break;
			}
		if (i != gap_fill_byte)		// only if change
			{
			gap_fill_byte = i;
			initialize_theImage(gap_fill_byte);
			sprintf(line, "%d", gap_fill_byte);
			camera_record_variable(Cam_gapfill, line);
			sprintf(line, "Set detector gap-fill to: %d", gap_fill_byte);
			}
		else
			sprintf(line, "Detector gap-fill is: %d", gap_fill_byte);
		printf("%s\n", line);
		OK_response(tx, Send, line);		// generic response
		break;

	// DiscardMultIm - control whether to discard multiple images
	// Usage:  discardmultim [y/n/0/1]
	case DiscardMultIm:
		if (*ptr != '\0' && !check_permission(DiscardMultIm))
			{
			if ((isdigit(*ptr) && *ptr!='0') || *ptr=='Y' || *ptr=='y')
				kill_mutiple_images=1;
			else
				kill_mutiple_images=0;
			}
		if (kill_mutiple_images)
			strcpy(line, "Multiple images will be zeroed");
		else
			strcpy(line, "Multiple images will be preserved");
		printf(" %s\n", line);
		OK_response(tx, Send, line);		// generic response
		break;

	// DacOffset - query or set the state of dac offset compensation
	// Usage:  dacoffset [on/off/0/1]
	case DacOffset:
		if (*ptr == '\0')
			{
			if (dac_offset_comp_enable)
				sprintf(line, "Dac offset compensation is ON\n");
			else
				sprintf(line, "Dac offset compensation is OFF\n");
			printf("%s\n", line);
			OK_response(tx, Send, line);		// generic response
			break;
			}
		if ( check_permission(DacOffset) )
			break;
		if (*ptr=='1' || !strncasecmp(ptr, "on", 2))
			dac_offset_comp_enable=1;
		else
			dac_offset_comp_enable=0;
		if (dac_offset_comp_enable)
			sprintf(line, "Dac offset compensation is ON\n");
		else
			sprintf(line, "Dac offset compensation is OFF\n");
		printf("%s\n", line);
		OK_response(tx, Send, line);		// generic response
		break;

	// MXsettings - query or set crystallography parameters
	// Usage: mxsettings [parm_name value [parm_name value] ...]
	case MXsettings:
		if (*ptr == '\0')
			{
			format_mx_params(bufr, sizeof(bufr));
			printf("%s", bufr);
			OK_response(tx, Send, bufr);		// generic response
			break;
			}
		// is the operator querying a single value?
		n=0;
		while(*(ptr+n) && !isspace(*(ptr+n)) )
			n++;
		while(*(ptr+n) && isspace(*(ptr+n)) )
			n++;
		if (!*(ptr+n))		// end of line?
			{
			format_mx_single(line, ptr);
			printf("%s\n", line);
			OK_response(tx, Send, line);		// generic response
			break;
			}
		if ( check_permission(MXsettings) )
			break;
		if ( (n = parse_mx_param_string(ptr)) )
			{
			sprintf(line, "Syntax error: %10s", ptr-1+n);
			if (tx)
				printf("%s\n", line);
			ERR_response(tx, Send, line);
			}
		else
			{
			if (tx)
				printf(" mxsettings: %s\n", ptr);
			OK_response(tx, Send, ptr);		// generic response
			}
		break;

	// CalibFile - query or set the the calibration file
	// Usage:  calibfile [path]
	case CalibFile:
		if (*ptr == '\0')		// report filename
			{
			if (detector_calibration_file[0])
				sprintf(line, "Calibration file:\n  %s", detector_calibration_file);
			else
				sprintf(line, "Calibration file is not set");
			if (tx)
				printf(" %s\n", line);
			OK_response(tx, Send, line);		// generic response
			break;
			}
		if ( check_permission(CalibFile) )
			break;
		for (i=strlen(ptr)-1; i && isspace(*(ptr+i)); i--)
			*(ptr+i) = '\0';			// trim trailing blanks, if any
		if (*(ptr+i) != '/')
			strcat(ptr, "/");			// trailing slash, if not there
		if (*ptr == '~')
			{
			strcpy(detector_calibration_file, getenv("HOME"));
			strcat(detector_calibration_file, ptr+1);
			}
		else
			strcpy(detector_calibration_file, ptr);
		if (tx)
			printf(" Changing detector_calibration_file to:\n   %s",
					detector_calibration_file);
		OK_response(tx, Send, detector_calibration_file);		// generic response
		break;

	// SetThreshold -  query or set the energy range (gain) and threshold
	// Usage:  setthreshold [[gain] threshhold] -or- setthreshold 0
	case SetThreshold:
		if (*ptr == '\0')		// report settings
			{
			show_calibration(bufr);
			printf(" %s\n", bufr);
			OK_response(tx, Send, bufr);
			break;
			}
		if ( check_permission(SetThreshold) )
			break;
		n = set_calibration(ptr, bufr);			// make up a command file
		if (n>0)
			{
			strcpy(line, "SetThreshold command - no change required");
			OK_response(tx, Send, bufr);		// print the message
			printf(" %s\n", line);
			printf(" %s\n", bufr);
			break;
			}
		if (n<0)
			{
			strcpy(line, "*** ERROR in SetThreshold command");
			ERR_response(tx, Send, bufr);		// print the message
			printf(" %s\n", line);
			printf(" %s\n", bufr);
			break;
			}
		strcpy(line, "/tmp/setthreshold.cmd");
		v = get_current_threshold();			// remember value
		set_current_threshold(0.0);				// turn off warning
		if (command_dispatcher(LdCmndFile, line, False))
			{
			ERR_response(tx, CamCmd, "");		// print the message
			printf("*** ERROR executing \"%s\"\n", line);
			}
		else
			{
			OK_response(tx, Send, line);
			printf("%s", bufr);
			printf(" \"%s\" was successful\n", line);
			set_current_threshold(v);			// set value on success
			}
		break;

	// LdBadPixMap - load a bad pixel map from a TIFF file
	// Usage:  ldbadpixmap full_path_name
	case LdBadPixMap:
		if (*ptr == '\0')		// report setting
			{
			if (bad_pix_file_name[0])
				sprintf(line, "Bad pixels loaded from\n  %s", bad_pix_file_name);
			else
				sprintf(line, "Bad pixel tagging is off");
			printf(" %s\n", line);
			OK_response(tx, Send, line);
			break;
			}
		if ( check_permission(LdBadPixMap) )
			break;
		if (load_bad_pixel_list(ptr))
			{
			ERR_response(tx, Send, "");
			break;
			}
		OK_response(tx, Send, "");
		camera_record_variable(Cam_badpixmap, ptr);
		break;

	// LdFlatField load a flat-field correction file - a floating point image
	// Usage:  ldflatfield full_path_name
	case LdFlatField:
		if (*ptr == '\0')		// report setting
			{
			if (flat_field_file_name[0])
				sprintf(line, "Flat field correction loaded from\n  %s", flat_field_file_name);
			else
				sprintf(line, "Flat field correction is off");
			printf(" %s\n", line);
			OK_response(tx, Send, line);
			break;
			}
		if ( check_permission(LdFlatField) )
			break;
		if (load_flat_field_correction_file(ptr))
			{
			ERR_response(tx, Send, "");
			break;
			}
		OK_response(tx, Send, "");
		camera_record_variable(Cam_flatfield, ptr);
		break;

	// SetAckInt - set or query the acknowledgement interval for the socket
	// Usage:  setackint [number]
	case SetAckInt:
		if (*ptr == '\0')		// report setting
			{
			sprintf(line, "Acknowledgement interval is %d", acknowledge_interval);
			printf(" %s\n", line);
			OK_response(tx, Send, line);
			break;
			}
		if ( check_permission(SetAckInt) )
			break;
		acknowledge_interval=atoi(ptr);
		OK_response(tx, Send, "");
		sprintf(line, "%d", acknowledge_interval);
		camera_record_variable(Cam_ackinterval, line);
		break;

	// SetEnergy - set or query the simplified gain and threshold setting
	// Usage:  setenergy [energy in eV]
	case SetEnergy:
		if (*ptr == '\0')		// report setting
			{
			if (set_energy_setting > 0.0)
				sprintf(line, "Requested energy setting: %.0lf eV",
						set_energy_setting);
			else
				sprintf(line, "Energy has not been set");
			printf(" %s\n", line);
			OK_response(tx, Send, line);
			break;
			}
		if ( check_permission(SetEnergy) )
			break;
		OK_response(tx, Send, "*** Under construction");
		printf("*** Under construction\n");
		break;

	// ScanDAC - make an exposure series while scanning a DAC or trims
	// Usage:  scandac dacname increment nexp filename
	case ScanDAC:
		if ( check_permission(ScanDAC) )
			break;
		cP = ptr;
		flag = 0;
		for (i=0; i<3; i++)		// count the delimiters
			{
			if (!(cP = strchr(cP, ' ')) )
				{
				flag++;
				break;
				}
			cP++;
			while(isspace(*cP))
				cP++;
			switch (i)
				{
				case 0:
					if ( !isdigit(*cP) && *cP!='-')		// 2nd arg is a number
						flag++;
					break;
				case 1:
					if ( !isdigit(*cP))		// 3rd arg is a number
						flag++;
					*(cP-1) = '\0';			// isolate "dacname increment" string
					n = atoi(cP);			// get count
					if (n < 1)
						flag++;
					break;
				case 2:
					break;
				}
			}
		if (flag || setup_file_series(cP) )
			{
			sprintf(line, "Syntax error - see usage");
			printf("%s\n", line);
			ERR_response(tx, Send, line);
			break;
			}
		command_dispatcher(NImages, "1", False);	// ni = 1
		if ( (p=next_file_in_series()) )
			strcpy(imgfile, p);
		else
			{
			sprintf(line, "Error setting up image file to write\n");
			printf("%s\n", line);
			ERR_response(tx, Send, line);
			break;
			}
		command_dispatcher(Exposure, p, False);			// 1st image
		while(timerRunning)
			exposure_service();							// wait for readout
		command_dispatcher(LogImgFile, "\0", False);
		if (strncasecmp(ptr, "TRIM", strlen("TRIM")))
			for(i=1; i<n; i++)
				{
				apply_deltaV(ptr);
				p=next_file_in_series();
				strcpy(imgfile, p);
				usleep(20000);							// V settling time
				command_dispatcher(Exposure, p, False);
				while(timerRunning)
					exposure_service();					// wait for readout
				command_dispatcher(LogImgFile, "\0", False);
				}
		else						// trim series
			for (i=1; i<n; i++)
				{
				sprintf(line, "Trim_all %d\n", i);
				printf("%s", line);
				command_interpreter(line, False);
				p=next_file_in_series();
				strcpy(imgfile, p);
				command_dispatcher(Fillpix, "", False);
				usleep(10000);							// settling time
				command_dispatcher(Exposure, p, False);
				while(timerRunning)
					exposure_service();					// wait for readout
				command_dispatcher(LogImgFile, "\0", False);
				}
		usleep(100000);
		OK_response(tx, Send, "");
		break;

	// ExpNaming - print a reference to the help file
	// Usage:  expnaming
	case ExpNaming:
		printf(" Please type 'help ExpNaming' in the tvx window\n");
		OK_response(tx, Send, "");
		break;


//================== testing ==========================

	// Cam_start - direct interface to camera_start
	// usage:  cam_start filebasename [time]
	case Cam_start:
		if ( check_permission(Cam_start) )
			break;
		val1 = 1.0;		// default value
		sscanf(ptr, "%s%lf", image_file, &val1);
		camera_start(&val1);
		break;

#if 0
	// manual exposure without readout
	case ETest:
			{double ddata;
			img_mode=1;
			ddata=1.0;
			sscanf(ptr, "%lf", &ddata);
			printf("Starting %.3lf sec. exposure\n", ddata);
			dcb_set_exposure_time(ddata);
			dcb_set_exposure_period(ddata+0.1);
			dcb_set_exposure_count_limit(1);
			dcb_set_tx_frame_limit(1);
		// start the exposure
			dcb_write_command_no_ack(0, (0x51<<24));	// DCB_EXPOSE
			}
		break;

	// Special parallel pixel fill:  pxfill xlen xoffset ylen yoffset
	case PxFill:
		ixo = 0;	// offfset
		iyo = 0;
		ixl = 60;	// length
		iyl = 97;
		n=0x9d367;
		sscanf(ptr, "%d%d%d%d%d", &ixl, &ixo, &iyl, &iyo, &n);
		dcb_reset_row_col(0);				// reset both shift registers
		for(i=0;i<ixl;i++)					// x-direction = columns
			dcb_insert_col_token(0);
		for(i=0;i<ixo;i++)					// shift block to position
			dcb_advance_col_token(0);
		for(i=0;i<iyl;i++)					// y-direction = rows
			dcb_insert_row_token(0);
		for(i=0;i<iyo;i++)
			dcb_advance_row_token(0);
		dcb_apply_din_value(0, n);	// fill selection with '1000'
		break;

	case PxF2:
		dcb_reset_row_col(0);				// reset both shift registers
		for(i=0;i<31;i++)					// x-direction = columns
			{
			dcb_advance_col_token(0);
			dcb_insert_col_token(0);
			}
		for(i=0;i<49;i++)					// y-direction = rows
			{
			dcb_advance_row_token(0);
			dcb_insert_row_token(0);
			}
		dcb_apply_din_value(0, 0x9d367);	// fill selection with '1000'
		break;

	case PxF4:
		dcb_reset_row_col(0);				// reset both shift registers
		dcb_insert_row_token(0);
		for(i=0;i<22;i++)
			dcb_advance_row_token(0);
		dcb_insert_col_token(0);
		for(i=0;i<60;i++)
			{
			dcb_apply_din_value(0, 0x9d367);
			dcb_advance_col_token(0);
			}
		dcb_advance_row_token(0);
		dcb_insert_col_token(0);
		for(i=0;i<60;i++)
			{
			dcb_apply_din_value(0, 0x9d367);
			dcb_advance_col_token(0);
			}
//		dcb_advance_row_token(0);
//		dcb_insert_col_token(0);
//		for(i=0;i<60;i++)
//			{
//			dcb_apply_din_value(0, 0x9d367);
//			dcb_advance_col_token(0);
//			}
		break;

	case PxF5:		// just 1 pixel
		dcb_reset_row_col(0);				// reset both shift registers
		dcb_insert_row_token(0);
		for(i=0;i<22;i++)
			dcb_advance_row_token(0);
		dcb_insert_col_token(0);
		dcb_apply_din_value(0, 0x9d367);

			// add the pixel above
		dcb_advance_row_token(0);
		dcb_apply_din_value(0, 0x9d367);
		break;
#else
ixl=iyl=ixo=iyo=0;		// keep compiler happy
#endif


