# p2_1chip.def - hardware definitions for sls10 chip
# specialized for  pilatus2 with testboard
# changed 17Dec04 PK & EFE
# 9 Apr 01 - new definition of "offset" = "old offset + LowL"
# DAC programming formula:
# (hex value) = 256*(voltage-offset) / (5*slope)

# DAC calibration (howto by pk):
# plot measured voltage in volts as function of decimal values that correspond
# to the hex values of the camserver.
# get slope m and offset b from fit.
# fill in m*51.2 in "slope" and b in "offset".


# this file numbers chip signals as 1 thru 16
# all modules are assumed identical in these properties

# module control signals <==> bit positions in pattern generator word

hardware_address_of_CHSEL_SDA    bit_0  # not used on sls07 1 chip board
hardware_address_of_DAC2_SDA     bit_1  # not used on sls07 1 chip board
hardware_address_of_SCL          bit_2
hardware_address_of_DAC1_SDA     bit_3


# bit positions of bank and module addresses
hardware_address_of_MOD_ADD_0      bit_9    # 3 bits wide => bits 9-11
hardware_address_of_MOD_ADD_1      bit_10
hardware_address_of_MOD_ADD_2      bit_11
hardware_address_of_BANK_ADD_0     bit_12    # 4 bits wide => bits 12-15
hardware_address_of_BANK_ADD_1     bit_13
hardware_address_of_BANK_ADD_2     bit_14
hardware_address_of_BANK_ADD_3     bit_15

# define logic "true" levels - 0 (low voltage) or 1 (high voltage)
# --- Example if high is "true"
# asserted_level_of_CHSEL_SDA  lvl_1
# asserted_level_of_SCL        lvl_1
# --- Example if low is "true"
# asserted_level_of_CHSEL_SDA  lvl_0
# asserted_level_of_SCL        lvl_0

# the asserted level is the level we must create at the source to logically
# assert the signal at the destination - i.e., this accounts for inversion

asserted_level_of_DAC1_SDA    lvl_0     # low is "true"
asserted_level_of_DAC2_SDA    lvl_0
asserted_level_of_CHSEL_SDA   lvl_0
asserted_level_of_SCL         lvl_0

asserted_level_of_MOD_ADD_0   lvl_1     # high is "true"
asserted_level_of_MOD_ADD_1   lvl_1
asserted_level_of_MOD_ADD_2   lvl_1
asserted_level_of_BANK_ADD_0  lvl_1
asserted_level_of_BANK_ADD_1  lvl_1
asserted_level_of_BANK_ADD_2  lvl_1
asserted_level_of_BANK_ADD_3  lvl_1

quiescent_level_of_DAC1_SDA   lvl_1     # I2C is high for queiescent state
quiescent_level_of_DAC2_SDA   lvl_1
quiescent_level_of_CHSEL_SDA  lvl_1
quiescent_level_of_SCL        lvl_1

quiescent_level_of_MOD_ADD_0   lvl_0     # our logic is low for quiescent state
quiescent_level_of_MOD_ADD_1   lvl_0
quiescent_level_of_MOD_ADD_2   lvl_0
quiescent_level_of_BANK_ADD_0  lvl_0
quiescent_level_of_BANK_ADD_1  lvl_0
quiescent_level_of_BANK_ADD_2  lvl_0
quiescent_level_of_BANK_ADD_3  lvl_0

# number of banks and modules configured
BANK_ADD_LO     1
BANK_ADD_HI     12
MODULE_ADD_LO   1
MODULE_ADD_HI   5

# Patterns are generated by changing bits in the base word.
# Unused bits are not changed.

PATTERN_BASE_WORD 0x8321

# Which pattern generator is used for I2C?  Default is 1, which is also used 
# when only 1 unit is available
I2C_VPG_UNIT 1


# clock frequency of the pattern generator, MHz
# this is the reciprocal of the time for 1 line of the pattern
# clock_frequency = crystal_frequency/(1 + clock_divider)
# clock_divider = 7 gives clk freq of 5 MHz with a 40 MHz crystal
# The program sets the clock divider to obtain the frequency specified here.
# By setting clock frequency to the system frequency, there is no change.
CLOCK_FREQUENCY  5
VPG_CRYSTAL_MHZ 40

# high level names <==> hardware names & properties
# E.g., DAC2 refers to DAC group 2, U3 is DAC 3 in the group, OUT2 is output 2

# name  hardware name   LowL    HiL    Offset   Slope
#these are the relevant Hardware names

# DAC1 U1 values
VCAL     DAC1_U1_OUT0    0.0     2.5   0.00236    0.248
VDEL     DAC1_U1_OUT1    0.0     2.5   0.0    0.49794
VTRM     DAC1_U1_OUT4    0.0     2.5   0.0    0.49794
VCMP     DAC1_U1_OUT5    0.0     2.5   0.0    0.49794

# DAC1 U2 values
VRF      DAC1_U2_OUT0   -2      1	 -0.68     	0.4301	
VRFS     DAC1_U2_OUT2   -2      1    0.0036    	0.4977
VCCA     DAC1_U2_OUT3    0.0    2.5   0.0      	0.49794

# Unused signals must be defined as 'NOT_USED' to avoid error messages
VADJ     NOT_USED
VRES     NOT_USED

VCMP0    NOT_USED
VCMP1    NOT_USED
VCMP2    NOT_USED
VCMP3    NOT_USED
VCMP4    NOT_USED
VCMP5    NOT_USED
VCMP6    NOT_USED
VCMP7    NOT_USED
VCMP8    NOT_USED

VCMP9    NOT_USED
VCMP10   NOT_USED
VCMP11   NOT_USED
VCMP12   NOT_USED
VCMP13   NOT_USED
VCMP14   NOT_USED
VCMP15   NOT_USED

CHSEL    CHSEL_U1_PATTERN		# special for CHSEL bit patterns
CHSEL0   NOT_USED
CHSEL1   NOT_USED
CHSEL2   NOT_USED
CHSEL3   NOT_USED
CHSEL4   NOT_USED
CHSEL5   NOT_USED
CHSEL6   NOT_USED
CHSEL7   NOT_USED
CHSEL8   NOT_USED
CHSEL9   NOT_USED
CHSEL10  NOT_USED
CHSEL11  NOT_USED
CHSEL12  NOT_USED
CHSEL13  NOT_USED
CHSEL14  NOT_USED
CHSEL15  NOT_USED


