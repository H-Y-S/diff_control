/*****************************************************************************\
** slsp2_1m_cam.pkg - a package of version-specific hardware commands for    **
** PILATUS2 single chip detectors.                                           **
**                                                                           **
** Other parts of this package are:                                          **
**           ./progi2c - routines to program i2c components                  **
**           ./rpc  -    routines to run the rpc interface to the ioc        **
**           ../../slsp2_1m/slsp2_1mod.pkg - commands for tvx                **
**                                                                           **
**   The camserver header file, camserver.h, is included by camclient.c to   **
** give camclient access to the case names.  This brings case names here     **
** into conflict withg those in tvx.  Thus I use the rather strange          **
** orthography seen here, e.g. SeT and ProG, which have the identical        **
** meaning as Set and Prog in tvx, but must be declared differently.         **
**                                                                           **
**   To return a message to the client, the routines OK_response(tx, ) and       **
** ERR_response(tx, ) are provided.  The message is caught by camclient.c        **
** for printing on the tvx screen.  Messages can be addressed to any of      **
** handlers programmed in camclient.c:check_camera_response(), which are     **
** very few in number.  Thus,  ERR_response(tx, CamCmd, "...") is a rather       **
** generic way to write a message on the tvx screen.  See 'LdCmdFile' or     **
** 'Exposure' for more specific applications.                                **
**                                                                           **
\*****************************************************************************/

	case SeT:
		if ( check_permission(SeT) )
			break;
		if (*ptr == '\0')
			printf("Usage:\n\t set dac_name volts ..or\n\n\t set chsel_name\n");
		else
			{
			if ( (i=set_i2c(ptr)) == 2 )	// set bank and/or mod
				break;
			else if (i)
				{
				ERR_response(tx, CamCmd, "*** Error from pattern composer");
				break;
				}
			goto CommonCode;
			}
		break;

	case Reset:
		if ( check_permission(Reset) )
			break;
		if (*ptr == '\0')
			printf("Usage:\n\t reset chsel_name\n");
		else
			{
			if (reset_i2c_chsel(ptr))
				{
				ERR_response(tx, CamCmd, "*** Error from pattern composer");
				break;
				}
			strcpy(ptr, ptr+2);		// remove "re" from "reset"
			goto CommonCode;
			}
		break;		

	case ProG:
		if ( check_permission(ProG) )
			break;
		if (*ptr == '\0')
			printf("Usage:\n\t prog dac_name (or chsel) 0xnn\n");
		else
			{
			if (prog_i2c(ptr))
				{
				ERR_response(tx, CamCmd, "*** Error from pattern composer");
				break;
				}
			goto CommonCode;
			}
		break;

	CommonCode:
		*line = '\0';					// ptr contains command text
		p=strrchr(ptr, ' ');			// point to last arg, if any
		if (p && isalpha(*(p+1)))		// pick up filename
			strcpy(line, p+1);
		else if (*outFileName)
			strcpy(line, outFileName);
		if (*line)
			{
			write_pattern(line, ptr);	// ptr used as title
			printf("Pattern was written to:\n     %s\n", line);
			}
		if (autoExec)
			{
			n = vpg_default_unit;
			vpg_execute_pattern(thePattern, patternP-thePattern, i2c_vpg_unit);
			if (pgRunning[vpg_default_unit] && n==i2c_vpg_unit)
				{
				vpg_set_jump(start_line, i2c_vpg_unit);	// resume execution of last pattern
//				vpg_start_clock(i2c_vpg_unit);
				}
			vpg_set_default(n);		// restore default unit
			}
		break;

	case Show:						// controlling process not required
		if (set_canonical_form(ptr))
			break;					// error - message already printed
		if ( (sp = getSetting(ptr)) )
			{
			if (sp->hadd.group == NOT_USED)
				{
				sprintf(line, "%s is not defined\n", ptr);
				printf("%s", line);
				if (tx)
					OK_response(tx, CamCmd, line);
				}
			else if (sp->hadd.group == CHIPSEL && sp->hadd.output > 16)
				{
				sprintf(line, "%s pattern is set to 0x%x\n", ptr, sp->binv);
				printf("%s", line);
				if (tx)
					OK_response(tx, CamCmd, line);
				}
			else if (sp->hadd.group == CHIPSEL)
				{
				sprintf(line, "%s is set to %d\n", ptr, sp->binv);
				printf("%s", line);
				if (tx)
					OK_response(tx, CamCmd, line);
				}
			else
				{
				sprintf(line, "%s is set to %6.3fV\n", ptr, sp->vset);
				printf("%s", line);
				if (tx)
					OK_response(tx, CamCmd, line);
				}
			}
		else
			{
			sprintf(line, "%s is not programmed\n", ptr);
			printf("%s", line);
			if (tx)
				OK_response(tx, CamCmd, line);
			}
		break;

	case Load:
		if ( check_permission(Load) )
			break;
		if (*ptr == '\0')
			printf("Usage:  Load filename\n");
		else
			load_configuration(ptr);
		break;

	case Save:
		if ( check_permission(Save) )
			break;
		if (*ptr == '\0')
			printf("Usage:\n\t Save filename\n");
		else
			save_configuration(ptr);
		break;

	case Filename:
		if ( check_permission(Filename) )
			break;
		if (strstr(ptr, "NUL") != NULL)
			{
			printf("Changing output filename to (null)\n");
			*outFileName = '\0';
			break;
			}
		if (*ptr)		// use orignal arg, not upper case version
			{
			outFileName[0]='\0';
			if (*ptr == '~')
				{
				strcpy(outFileName, getenv("HOME"));
				strcat(outFileName, ptr+1);
				}
			else if (strchr(ptr, '/') == NULL)		// was a path specified?
				{
				strcpy(outFileName, cam_data_path);		// no, use this path
				strcat(outFileName, ptr);
				}
			else
				strcpy(outFileName, ptr);
			printf("Changing output file name to: %s\n", ptr);
			break;
			}
		if (*outFileName)
			printf("Output file is: %s\n", outFileName);
		else
			printf("No output file is set\n");
		break;

	case AutoExec:
		if ( check_permission(AutoExec) )
			break;
		if (!*ptr)
			{
			if (autoExec)
				printf("AutoExec is on\n");
			else
				printf("AutoExec is off\n");
			}
		else
			{
			if (!strncmp(ptr, "ON", 2))
				autoExec = True;
			else if (!strncmp(ptr, "OFF", 3))
				autoExec = False;
			else
				printf("Can't find \"on\" or \"off\" in %s\n", ptr);
			}
		break;

	case LoadPattern:
		if ( check_permission(LoadPattern) )
			break;
		if (*ptr == '\0')
			printf("Usage:\n\tLoadpattern filename <offset>\n");
		else if(vpg_load_pattern(ptr, vpg_default_unit) && tx)
			ERR_response(tx, CamCmd, "");
		break;

	case RuN:
		if ( check_permission(RuN) )
			break;
		vpg_stop_clk(vpg_default_unit);
		if (*ptr == '\0')
			{
			vpg_set_jump(start_line, vpg_default_unit);
			vpg_start_clock(vpg_default_unit);
			}
		else
			{
			if (!vpg_load_pattern(ptr, vpg_default_unit));
				{
				vpg_set_jump(start_line, vpg_default_unit);
				vpg_start_clock(vpg_default_unit);
				}
			}
		break;

	case Set_clk_divideR:
		if (*ptr == '\0')
			{
			if (clock_divider2 < 0)		// ie, only 1 vpg
				printf("Clock divider 1 = %d\n", clock_divider1);
			else
				printf("Clock divider 1 = %d; clock divider 2 = %d\n",
						clock_divider1, clock_divider2);
			break;
			}
		if ( check_permission(Set_clk_divideR) )
			break;
		sscanf(ptr, "%d", &div);
		vpg_set_clk_divider(div, vpg_default_unit);
		break;

	case Pc_reseT:
		if ( check_permission(Pc_reseT) )
			break;
		vpg_pc_reset(vpg_default_unit);
		start_line = 0;
		break;

	case Pc_set:
		if ( check_permission(Pc_set) )
			break;
		data = 0;		// default
		sscanf(ptr, "%i", &start_line);
		vpg_set_jump(start_line, vpg_default_unit);
		break;

	case StarT:
		if ( check_permission(StarT) )
			break;
		if (*ptr)
			sscanf(ptr, "%i", &start_line);
//		vpg_stop_clk();			// not needed & costs 2-3 ms
		vpg_set_jump(start_line, vpg_default_unit);
		if (!pgRunning[vpg_default_unit])
			vpg_start_clock(vpg_default_unit);
		pgRunning[vpg_default_unit]=True;
		break;

	case StoP:
		if ( check_permission(StoP) )
			break;
		vpg_stop_clk(vpg_default_unit);
		pgRunning[vpg_default_unit]=False;
		break;

	case Peek:
		if(*ptr == '\0')
			printf("Usage:\n\tpeek address\n");
		else
			{
			sscanf(ptr, "%i", &addr);
			vpg_read_p(addr, vpg_default_unit);
			}
		break;

	case Poke:
		if ( check_permission(Poke) )
			break;
		if(*ptr == '\0')
			printf("Usage:\n\tpoke address data\n");
		else
			{
			sscanf(ptr, "%i%Li", &addr, &dataL);
			data = (unsigned int)dataL;
			vpg_write(addr, data, vpg_default_unit);
			}
		break;

	case PeekL:
		if(*ptr == '\0')
			printf("Usage:\n\tpeek line_no\n");
		else
			{
			sscanf(ptr, "%i", &addr);
			vpg_read_p(addr<<2, vpg_default_unit);
			}
		break;

	case PokeL:
		if ( check_permission(PokeL) )
			break;
		if(*ptr == '\0')
			printf("Usage:\n\tpoke line_no data\n");
		else
			{
			sscanf(ptr, "%i%Li", &addr, &dataL);
			data = (unsigned int)dataL;
			vpg_write(addr<<2, data, vpg_default_unit);
			}
		break;

/* inserted by Stefan Kohout on 24.7.2000 ----------------- */
/* --- to be able to use poked line_no(dec) data(hex) ---*/

	case PokeD:
		if ( check_permission(PokeL) )
			break;
		if(*ptr == '\0')
			printf("Usage:\n\tpoked line_no(dec) data(hex)\n");
		else
			{
			sscanf(ptr, "%i%x", &addr, &data);
			vpg_write(addr<<2, data, vpg_default_unit);
			}
		break;

/* end of insertion by Stefan Kohout ------------------------ */

	case Fpeek:
		if(*ptr == '\0')
			printf("Usage:\n\tpeek address\n");
		else
			{
			sscanf(ptr, "%i", &addr);
			fifo_read(addr);
			}
		break;

	case Fpoke:
		if ( check_permission(Fpoke) )
			break;
		if(*ptr == '\0')
			printf("Usage:\n\tpoke address data\n");
		else
			{
			sscanf(ptr, "%i%i", &addr, &data);
			fifo_write(addr, data);
			}
		break;

	case Status:
		vpg_read_status_p(vpg_default_unit);
		fifo_read_status_p();
		break;

	case Vstatus:
		vpg_read_status_p(vpg_default_unit);
		break;

	case Fstatus:
		fifo_read_status_p();
		break;

	case Vwrite_status:
		if ( check_permission(Vwrite_status) )
			break;
		sscanf(ptr, "%hi", &vstat);
		vpg_write_status(vstat, vpg_default_unit);
		break;

	case Fwrite_controL:
		if ( check_permission(Fwrite_controL) )
			break;
		sscanf(ptr, "%hi", &vstat);
		fifo_write_control(vstat);
		break;

	case Fwrite_test:
		if ( check_permission(Fwrite_test) )
			break;
		sscanf(ptr, "%hi", &vstat);
		fifo_write_test(vstat);
		break;

	case Fread_event:
		fifo_read_event();
		break;

	case Fread_data:
		fifo_read_data();
		break;

	case Fwrite_data:
		if ( check_permission(Fwrite_data) )
			break;
		sscanf(ptr, "%hi", &vstat);
		fifo_write_data(vstat);
		break;

	case Fwait_time:
		if ( check_permission(Fwait_time) )
			break;
		if (*ptr)
			{
			sscanf(ptr, "%i", &fifo_timeout);
			printf("Setting fifo timeout to %d seconds\n", fifo_timeout);
			}
		else
			printf("Fifo timeout is %d seconds\n", fifo_timeout);
		break;

// --- read an image as 32-bit integers thru the rpc interface
// --- output both a ".img" file (truncated to 16-bit) and a ".dat" file (text)
	case ImG:
		if ( check_permission(ImG) )
			break;
		if (fifo_read_status() & 0x80)
			{
			printf("Fifo is empty\n");
			break;
			}
		if (fifo_read_status() & 0x10)
			{
			printf("Fifo is busy\n");
			break;
			}
		fifo_wait_busy(fifo_timeout);
		fifo_read_image();
		printf("Image length was %d\n", imageLength);
		DBG(3, "Image length was %d\n", imageLength);
		if (imageLength == 0)
			{
			if (tx)
				ERR_response(tx, CamCmd, "");
			break;
			}
		if (strstr(ptr, "NUL"))		// nul, null, etc shuts off filesave
			strcpy(autofilename, "null");
		*datfile = '\0';
		*imgfile = '\0';
		if (*ptr)
			{
			if ( (p=strchr(ptr, ' ')) )		// remove trailing blanks
				*p = '\0';
			if (*ptr == '~')
				{
				strcpy(datfile, getenv("HOME"));
				strcat(datfile, ptr+1);
				}
			else if ( strchr(ptr, '/') == NULL )	// no path - use default
				{
				strcpy(datfile, cam_image_path);
				strcat(datfile, ptr);
				}
			else
				strcpy(datfile, ptr);		// path given
			strcpy(imgfile, datfile);		// make up file names
			strcat(datfile, ".dat");
			strcat(imgfile, ".img");
			}
		else		// no filename given - use auto
			{
			strcpy(datfile, cam_image_path);
			strcat(datfile, autofilename);		// make up filenames
			sprintf(datfile+strlen(datfile), "_%04d", filenumber);
			filenumber++;
			strcpy(imgfile, datfile);
			strcat(datfile, ".dat");
			strcat(imgfile, ".img");
			}
		if (*datfile)
			{
			if ((ofp = fopen(datfile, "w")) == NULL)
				{
				printf("Could not open %s for writing\n", datfile);
				break;
				}
			if ((ofd = open(imgfile, O_WRONLY | O_CREAT | O_TRUNC,
						S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH)) == -1)
				{
				printf("Could not open %s for writing\n", imgfile);
				fclose(ofp);
				break;
				}
			fprintf(ofp, "Image length was %d\n", imageLength);
			if (fifo_data_true_level)
				{
				for (i=0; i<imageLength; i++)
					{
					fprintf(ofp, "%5d  ", i);
					for (j=NBITS; j; j--)
						{
						if (theImage[i] & (1<<(j-1)))
							fprintf(ofp, "1");
						else
							fprintf(ofp, "0");
						}
					fprintf(ofp, "  %#4x\n", xor_table[theImage[i]] );
					}
				}
			else
				{
				fprintf(ofp, "Asserted level is 0; bits are shown inverted\n");
				for (i=0; i<imageLength; i++)
					{
					fprintf(ofp, "%5d  ", i);
					for (j=NBITS; j; j--)
						{
						if (theImage[i] & (1<<(j-1)))
							fprintf(ofp, "0");
						else
							fprintf(ofp, "1");
						}
					fprintf(ofp, "  %#4x\n", xor_table[theImage[i]] );
					}
				}
			printf("File %s was written\n", datfile);
			fclose(ofp);
			xor_decode_image(img_mode);	// mode 0 =  do not process extra pixels
			truncate_image(theImage, imageLength);		// in-place 32 to 16 bit
			write(ofd, theImage, imageLength*sizeof(unsigned short));
			close(ofd);
			printf("File %s was written\n", imgfile);
			}
		else		// no file output desired
			{
			for (i=0; i<imageLength; i++)
				{
				printf("%5d  ", i);
				for (j=NBITS; j; j--)
					{
					if (theImage[i] & (1<<(j-1)))
						printf("1");
					else
						printf("0");
					}
				printf("  %#4x\n", xor_table[theImage[i]] );
				}
			}
		if (tx)
			OK_response(tx, CamCmd, "");
		break;

// --- inserted by Stefan Kohout on 3.10.2000
// --- Only a ".img" file - no text file
// --- sls42 uses 32-bit rpc interface; sls8x2 and slsdet use nfs from the ioc
	case ImgonlY:
		if ( check_permission(ImgonlY) )
			break;
		// for sls P2 chip - everything is done in fifo.c
		if (strstr(ptr, "NUL"))		// nul, null, etc shuts off filesave
			strcpy(autofilename, "null");
		*imgfile = '\0';
		if (*ptr)
			{
			if ( (p=strchr(ptr, ' ')) )		// remove trailing blanks
				*p = '\0';
			if (*ptr == '~')
				{
				strcpy(imgfile, getenv("HOME"));
				strcat(imgfile, ptr+1);
				}
			else if ( strchr(ptr, '/') == NULL )	// no path - use default
				{
				strcpy(imgfile, cam_image_path);
				strcat(imgfile, ptr);
				}
			else
				strcpy(imgfile, ptr);		// path given
			strcat(imgfile, ".img");
			}
		else		// no filename given - use auto
			{
			strcpy(imgfile, cam_image_path);
			strcat(imgfile, autofilename);		// make up filenames
			sprintf(imgfile+strlen(imgfile), "_%04d", filenumber);
			filenumber++;
			strcat(imgfile, ".img");
			}
		if (*imgfile)
			{
			p = imgfile;
			if (strstr(p, cam_image_path))		// remove local path
				p += strlen(cam_image_path);
			write_image_nfs(p, img_mode);	// direct write
			DBG(3, "Imgonly file name: %s\n", p);
			}
		else
			printf("***Could not get the image file name\n");
		if (tx)
			OK_response(tx, CamCmd, "");
		break;
// --- end of insertion by Stefan Kohout

	case Vclear:
		if ( check_permission(Vclear) )
			break;
		vpg_clear(vpg_default_unit);
		break;

	case Initialize:
		if ( check_permission(Initialize) )
			break;
		vpg_init();
		fifo_init();
		break;

	case Step:
		if ( check_permission(Step) )
			break;
		vpg_step(vpg_default_unit);	// assume we are stepping from start_line
		start_line++;	// update for possible "start" command
		break;

#ifdef SLSP2_1C_CAMERA
	case Trim:			// trim x y value - set trim in 1 pixel
		if ( check_permission(Trim) )
			break;
		row = col = value = -999;		// flag
		sscanf(ptr, "%d%d%i", &col, &row, &value);	// get parameters
		if (row == -999)
			{
			printf ("Usage: trim x y <value>\n");
			break;
			}
		// assume chip coordinates
		if (row < 0 || row >= NROW_CHIP)
			{
			printf("Row out of bounds: %d\n", row);
			break;
			}
		if (col < 0 || col >= NCOL_CHIP)
			{
			printf("Column out of bounds: %d\n", col);
			break;
			}
		if (value == -999)	// no value asks for current setting
			{
			if (trimValues[row][col] == -1)
				printf("Trim: x= %d, y = %d is not set\n", col, row);
			else
				printf("Trim: x= %d, y = %d set to: %d\n", col, row, trimValues[row][col]);
			break;
			}
		if (value < 0 || value > MAX_TRIM_VALUE)
			{
			printf("Trim value out of bounds: %d\n", value);
			break;
			}
			// put the value into the array
		trimValues[row][col] = value;
		trimallVal = -1;		// signal that not all trims are the same
			// if we are loading from a file, we're done
		if (loadingTrimFile)
			break;
		setTrims();		// load trim bits into all pixels
		if (pgRunning[vpg_default_unit])
			vpg_set_jump(start_line, vpg_default_unit);				// restart pattern
		if (tx)
			OK_response(tx, CamCmd, "");
		break;
#endif
#ifdef SLSP2_1M_CAMERA
	case Trim:			// trim x y value - set trim in 1 pixel or read-back setting
		// NB - bits are inverted: 0 means write all 1's, which turns off trim
		if ( check_permission(Trim) )
			break;
		row = col = value = -99;		// flag
		sscanf(ptr, "%d%d%i", &col, &row, &value);	// get parameters
		if (row == -99)
			{
			printf ("Usage: trim x y <value>\n");
			break;
			}
		if (selected_chip < 0)		// assume module coordinates
			{
			if (row < 0 || row >= NROW_MOD)
				{
				printf("Module row out of bounds: %d\n", row);
				break;
				}
			if (col < 0 || col >= NCOL_MOD)
				{
				printf("Module column out of bounds: %d\n", col);
				break;
				}
			}
		else			// assume chip coordinates
			{
			if (row < 0 || row >= NROW_CHIP)
				{
				printf("Chip row out of bounds: %d\n", row);
				break;
				}
			if (col < 0 || col >= NCOL_CHIP)
				{
				printf("Chip column out of bounds: %d\n", col);
				break;
				}
			}
		if (value == -99)	// no value asks for current setting
			{
			// slsp2_1m: trimValues[NCHIP][NROW_CHIP][NCOL_CHIP]
			if (selected_chip < 0)		// assume module coordinates
				{
				px = pix_add(-1, col, row, -1, -1, -1);
				if (px->cx < 0)
					{
					printf("Pixel not in a chip\n");
					break;
					}
				if (trimValues[px->cn][px->cy][px->cx] == -1)
					printf("Trim: ch = %d, x= %d, y = %d is not set\n", 
							px->cn, px->cx, px->cy);
				else
					printf("Trim: ch = %d, x= %d, y = %d set to: %d\n",
							px->cn, px->cx, px->cy, trimValues[px->cn][px->cy][px->cx]);
				}
			else						// assume chip coordinates
				{
				if (trimValues[selected_chip][row][col] == -1)
					printf("Trim: ch = %d, x= %d, y = %d is not set\n", 
							selected_chip, col, row);
				else
					printf("Trim: ch = %d, x= %d, y = %d set to: %d\n",
							selected_chip, col, row, trimValues[selected_chip][row][col]);
				}
			break;
			}
		// from here, 'tis a trim command to a chip
		if (selected_chip < 0)
			{
			printf("Exactly 1 chip must be selected for trim command\n");
			if (tx)
				ERR_response(tx, CamCmd, "Exactly 1 chip must be selected");
			break;
			}
		if (value < 0 || value > MAX_TRIM_VALUE)
			{
			printf("Trim value out of bounds: %d\n", value);
			break;
			}
			// put the value into the array
		trimValues[selected_chip][row][col] = value;
		trimallVal = -1;		// signal that not all trims are the same
			// if we are loading from a file, we're done
		if (loadingTrimFile)
			break;
		setTrims();		// load trim bits into all pixels
		if (pgRunning[vpg_default_unit])
			vpg_set_jump(start_line, vpg_default_unit);				// restart pattern
		if (tx)
			OK_response(tx, CamCmd, "");
		break;
#endif
#ifdef SLSP2DET_CAMERA
#error
#endif

	case Trim_all:		// trim_all value - set all pixels to same trim
		// NB - bits are inverted: 0 means write all 1's, which turns off trim
		if ( check_permission(Trim_all) )
			break;
		sscanf(ptr, "%i", &value);		// get the trim value
		if (value < 0 || value > MAX_TRIM_VALUE)
			{
			printf("Trim value out of bounds: %d\n", value);
			break;
			}
		init_trim_array(value);
		trimallVal = value;		// signal that trims are all the same
		setPatternTrimBits(value, base_trim_all_pattern+OFFSET_TRIM_ALL_PATTERN, -1);
		vpg_stop_clk(vpg_default_unit);
		vpg_set_jump(base_trim_all_pattern, vpg_default_unit);
		vpg_start_clock(vpg_default_unit);
		if (tx)
			OK_response(tx, CamCmd, "");
		break;

	case SetTrims:			// set trims from stored array
		if ( check_permission(SetTrims) )
			break;
		setTrims();					// (re)set trims from array - in ppg_util.c
		if (tx)
			OK_response(tx, CamCmd, "");
		break;

	case TrimFromFile:			// load trims from a file
		if ( check_permission(TrimFromFile) )
			break;
		if (*ptr)			// remember trimFileName as default
			{
			if (*ptr == '/')					// if path is given
				strcpy(trimFileName, ptr);
			else if (*ptr == '~')
				{
				strcpy(trimFileName, getenv("HOME"));
				strcat(trimFileName, ptr+1);
				}
			else								// make up full path
				{
				strcpy(trimFileName, cam_data_path);
				strcat(trimFileName, ptr);
				}
			}
		if (*trimFileName == '\0')
			{
			printf("Need a file name\n");
			break;
			}
		strcpy(line, "LdCmndFile ");		// make up command
		strcat(line, trimFileName);
		loadingTrimFile = True;
		if (command_interpreter(line, False))
			{
			strcpy(line, "Cannot find file: ");
			strcat(line, trimFileName);
			ERR_response(tx, CamCmd, line);		// print the message
			break;
			}
		loadingTrimFile = False;	// finished loading trims
					// the command 'settrims' should be in the file
		trimallVal = -1;			// signal that not all trims are the same
		if (tx)
			OK_response(tx, CamCmd, "");
		break;

	case LogImgFile:		// log last image parameters to 'params.txt' file
		if ( check_permission(LogImgFile) )
			break;
		for(bank=1; bank<=NBANK; bank++)
			{
			for(mod=1; mod<=NMOD_BANK; mod++)
				{
				sprintf(line, "B%d_M%d", bank, mod);
				set_canonical_form(line);	// set default bank & mod as applicable
				p = line2;					// make up text here
				*p = '\0';
				strcpy(line, "VCAL");
				if (set_canonical_form(line))
					break;					// error - message already printed
				if ( (sp = getSetting(line)) )
					{
					vcal = sp->vset;
					sprintf(p, "%6.3f    ", vcal);
					}
				else
					{
					vcal = 0.0;
					strcat(p, "   ??    ");
					}
				p += strlen(p);
											// value of VRF
				get_vrfall(line, bank, mod);
				strcat(p, line);
				p += strlen(p);
											// value of VRFS
				get_vrfsall(line, bank, mod);
				strcat(p, line);
				p += strlen(p);
											// value of VTRM
				get_vtrmall(line, bank, mod);
				strcat(p, line);
				p += strlen(p);
											// value of VCMP
				get_vcmpall(line, bank, mod);
				strcat(p, line);
				p += strlen(p);
											// TRIM value or filename from last trim
				if (trimallVal < 0)			// trims not all the same - use filename
					{
					if ( strrchr(trimFileName, '/') )
						{					// if it was an autotrim file, make up name
						strcpy(line, ".");
						strcat(line, strrchr(trimFileName, '/'));
						if ( (cP=strstr(line, "autotrim")) )
							{
							*(cP+strlen("autotrim")) = '\0';
							moduleFilename(line, NULL, "", bank, mod);
							}
						strcat(p, line);
						strcat(p, "  ");
						}
					else
						strcat(p, "  * ");		// no info on trim file name
					}
				else						// uniform trim value
					sprintf(p, "%4d ", trimallVal);
				p += strlen(p);
											// the image filename - relative to here
				strcpy(line, "  .");
				strcat(line, strrchr(imgfile, '/'));
				strcat(p, line);
				strcat(p, "\n");
											// append to image params file in same directory
				strcpy(line, imgfile);
				*(1+strrchr(line, '/')) = '\0';
				moduleFilename(line, NULL, "params.txt", bank, mod);
				DBG(3, "LogImgFile - appending to %s\n", line);
				if ( (ofp=fopen(line, "a")) == NULL)
					{
					printf("Unable to open %s for writing\n", line);
					break;
					}
				fputs(line2, ofp);
				fclose(ofp);
				}
			}
		break;

#ifdef TWO_VPGS
	case Set_vpg:				// set or report default vpg unit
		if ( check_permission(Set_vpg) )
			break;
		if (*ptr)
			vpg_set_default(atoi(ptr));
		else
			printf("Default VPG unit is %d\n", vpg_default_unit);
		break;
#else
	case Set_vpg:				// set or report default vpg unit
		if (*ptr == '\0')
			printf("VPG unit is %d (only 1 defined)\n", vpg_default_unit);
		else if (*ptr && 1==atoi(ptr))
			break;				// silently accept this
		else
			printf("Cannot set VPG - only 1 defined\n");
		break;
#endif		// TWO_VPGS

	case Read_signals:			// re-read signal definitions
		if ( check_permission(Read_signals) )
			break;
		if (*ptr)
			read_detector_info(ptr);
		else
			printf("File name required\n");
		break;

	case LogSettings:			// log i2c settings to treport.txt
		if ( check_permission(LogSettings) )
			break;
		strcpy(line, cam_image_path);
		strcat(line, ptr);
		if (*(line+strlen(line)-1) != '/')
			strcat(line, "/");
		strcat(line, "treport.txt");
		if ( (ofp = fopen(line, "a")) == NULL)
			{
			printf("LogSettings - Could not open file for appending:\n\t%s\n",
				line);
			break;
			}
		else
			{
			printf("LogSettings from stored values to:\n");
			printf("\t%s\n", line);
			DBG(3, "LogSettings to %s\n", line);
			*(1+strrchr(line, '/')) = '\0';		// isolate path
			log_i2c_settings(ofp, line);
			log_gpib_readings(ofp);
			fclose(ofp);
			}
		break;

	case ImgMode:		// x-rays vs. pulses
		if (NCHIP == 1)			// only 1 chip in system
			{
			printf("Only 1 chip declared - img_mode is pulses\n");
			break;
			}
		if (*ptr == 'X' || *ptr == '1' )
			{
			img_mode = 1;
			xor_tab_initialize(0x0);
			}
		else if (*ptr == 'P'|| *ptr == '0' )
			{
			img_mode = 0;
			xor_tab_initialize(0xffff);
			}
		else
			{
			if (img_mode)
				printf("Img_mode is x-rays\n");
			else
				printf("Img_mode is pulses\n");
			}
		break;

#ifdef USE_GPIB
	case Gpibsend_volt:
		if ( check_permission(Gpibsend_volt) )
			break;
		gpibsend_vo(ptr);
		break;

	case Gpibsend_scope:
		if ( check_permission(Gpibsend_scope) )
			break;
		gpibsend_os(ptr);
		break;
	
	case Gpibread_volt:
		gpibread_vo();
		break;

	case Gpibread_scope:
		gpibread_os(ptr);
		break;

	case Scopeimg:
		if ( check_permission(Scopeimg) )
			break;
		imgfile[0]='\0';
		if (*ptr!='/')
			strcpy(imgfile, cam_image_path);
		strcat(imgfile, ptr);
		if ((ofd = open(imgfile, O_WRONLY | O_CREAT | O_TRUNC,
					S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH)) == -1)
			{
			printf("Could not open %s for writing\n", imgfile);
			break;
			}
		truncate_image(theImage, NCOL_CHIP*NROW_CHIP);		// in-place 32 to 16 bit
		write(ofd, theImage, NCOL_CHIP*NROW_CHIP*sizeof(unsigned short));
		close(ofd);
		printf("Writing: %s\n", imgfile);
		memset(theImage, 0, NCOL_CHIP*NROW_CHIP*sizeof(int));
		break;
#else
	case Gpibsend_volt:
	case Gpibsend_scope:
	case Gpibread_volt:
	case Gpibread_scope:
	case Scopeimg:
		printf("GPIB operations not enabled\n");
		break;
#endif		// USE_GPIB

	case Pwait:				// wait for pattern to finish up to n seconds
		if ( check_permission(Pwait) )
			break;
		time_lim = 0;
		if (*ptr)
			sscanf(ptr, "%d", &time_lim);		// pick up time limit
		time_lim = max(1, time_lim);
		vpg_wait_pattern(time_lim, vpg_default_unit);
		break;

	// declare start addresses of patterns - see cam_config.c & cam_config.h
	case Base_trmall:		// pick up pattern address
		if ( check_permission(Base_trmall) )
			break;
		sscanf(ptr, "%i", &base_trim_all_pattern);
		camera_record_variable(Base_trim_all_pattern, ptr);
		break;

	case Base_readchip0:
		if ( check_permission(Base_readchip0) )
			break;
		sscanf(ptr, "%i", &base_read_chip_pattern0);
		camera_record_variable(Base_read_chip_pattern0, ptr);
		break;

	case Base_readchip1:
		if ( check_permission(Base_readchip1) )
			break;
		sscanf(ptr, "%i", &base_read_chip_pattern1);
		camera_record_variable(Base_read_chip_pattern1, ptr);
		break;

	case Base_enable:
		if ( check_permission(Base_enable) )
			break;
		sscanf(ptr, "%i", &base_enable_pattern);
		camera_record_variable(Base_enable_pattern, ptr);
		break;

	case Base_disable:
		if ( check_permission(Base_disable) )
			break;
		sscanf(ptr, "%i", &base_disable_pattern);
		camera_record_variable(Base_disable_pattern, ptr);
		break;

	case Base_i2cpat:		// pick up pattern address
		if ( check_permission(Base_i2cpat) )
			break;
		sscanf(ptr, "%i", &i2c_pattern_base);
		camera_record_variable(I2c_pattern_base, ptr);
		break;

	//-- BHe 	
	case Base_vpg_ena:
		if ( check_permission(Base_vpg_ena) )
			break;
		sscanf(ptr, "%i", &base_vpg_ena_pattern);
		camera_record_variable(Base_vpg_ena_pattern, ptr);
		break;

	case SetNImages:
		if ( check_permission(SetNImages) )
			break;
		if (*ptr)
			sscanf(ptr, "%d", &n_images);
		else
			printf("Number of images set to: %d\n", n_images);
		break;

// SPring8 BL38b1 commands
#ifdef SP8_BL38B1
	case Cm_input:
		cm_input(bufr);		// bufr will contain the data read
		break;

	case Cm_output:
		if ( check_permission(Cm_output) )
			break;
		cm_output(ptr);
		break;

	case Cm_shutter:
		if ( check_permission(Cm_shutter) )
			break;
		cm_shutter(atoi(ptr));
		break;

	case Cm_getmotval:
		cm_getmotval();
		break;

	case Cm_putmotval:
		if ( check_permission(Cm_putmotval) )
			break;
		cm_putmotval();
		break;

	case Cm_check_motion:
		if ( check_permission(Cm_check_motion) )
			break;
		cm_check_motion();
		break;

	case Cm_moveto:
		if ( check_permission(Cm_moveto) )
			break;
		sscanf(ptr, "%s%lf%lf", line, &val1, &val2);
		cm_moveto(line, val1, val2);
		break;

	case Cm_manual:
		if ( check_permission(Cm_manual) )
			break;
		cm_manual(atoi(ptr));
		break;

	case Cm_home:
		if ( check_permission(Cm_home) )
			break;
		cm_home();
		break;

	case Cm_dc:
		if ( check_permission(Cm_dc) )
			break;
		sscanf(ptr, "%s%lf%lf", line, &val1, &val2);
		cm_dc(line, val1, val2);
		break;
#endif		// SP8_BL38B1

// Cam_start - direct interface to camera_start - use with fine-slice mode
// usage:  cam_start filebasename [time]
	case Cam_start:
		if ( check_permission(Cam_start) )
			break;
		val1 = 1.0;		// default value, not acutally used at present
		sscanf(ptr, "%s%lf", image_file, &val1);
		camera_start(&val1);
		break;

// DataSection - write a DataSection identifier line to all param files
// using the path of the last image file
// usage:  datasection any_text
	case DataSection:
		if ( check_permission(DataSection) )
			break;
		if (!imgfile[0])
			{
			printf("***Can't find image name for path\n");
			break;
			}
		strcpy(line2, "# DataSection ");
		strcat(line2, ptr);
		strcat(line2, "\n");
		for(bank=1; bank<=NBANK; bank++)
			{
			for(mod=1; mod<=NMOD_BANK; mod++)
				{
				strcpy(line, imgfile);	// append to params files in same directory
				*(1+strrchr(line, '/')) = '\0';
				moduleFilename(line, NULL, "params.txt", bank, mod);
				DBG(3, "DataSection - appending to %s\n", line);
				if ( (ofp=fopen(line, "a")) == NULL)
					{
					printf("Unable to open %s for writing\n", line);
					break;
					}
				fputs(line2, ofp);
				fclose(ofp);
				}
			}
		*(1+strrchr(line, '/')) = '\0';
		printf("DataSection directory: %s\n", line);
		break;

