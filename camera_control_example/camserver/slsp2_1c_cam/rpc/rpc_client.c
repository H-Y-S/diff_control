/*
** This is sample code generated by rpcgen.
** These are only templates and you can use them
** as a guideline for developing your own functions.
*/

// original by B. Schmitt from template produced by rpcgen
// adapted for ppg by EFE, 10 May 00

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <time.h>
#include "ioc_rpc.h"
#include "ppg_util.h"
#include "cam_config.h"
//#include "camserver.h"
#include "pix_detector.h"
#include "cam_tbl.h"
#include "debug.h"
#include "rpc_server/vpg.h"
 
#define VPG_JUMP_MASK 0xffff807f
#define VPG_STATUS_REG 0x1fffc
#define VPG_INPUT_REG 0x1ffe8
#define FIFO_STATUS_REG 0x8
#define NSELECTORS 16

#define ENABLE_NFS_WRITE


/* prototypes of internal functions */
static char *findData(char *);
static void get_client(CLIENT **, int *);
static void client_destroy(CLIENT *, int *);

static void vpg_initialize(CLIENT *, int *);
static void vpg_clock_stop(CLIENT *, int *);
static void vpg_clock_start(CLIENT *, int *);
static void vpg_set_clock_divider(CLIENT *, int *, int);
static void vpg_reset_program_counter(CLIENT *, int *);
static void vpg_clear_memory(CLIENT *, int *);
static void vpg_step_clk(CLIENT *, int *);
static void vpg_set_jump_addr(CLIENT *, int *, unsigned int);
static void vpg_read_reg(CLIENT *, int *, unsigned int, unsigned int *);
static void vpg_write_reg(CLIENT *, int *, unsigned int, unsigned int);
static void vpg_set_default_unit(CLIENT *, int*, int);

static void fifo_initialize(CLIENT *, int *);
static void fifo_write_reg(CLIENT *, int *, unsigned int, unsigned int);
static void fifo_read_reg(CLIENT *, int *, unsigned int, unsigned int *);
static void fifo_read_stat(CLIENT *, int *, unsigned int*);
static void fifo_read_dat(CLIENT *, int *, unsigned int *);
static void fifo_read_event_ctr(CLIENT *, int *, unsigned int *);
static void fifo_write_dat(CLIENT *, int *, unsigned int);
static void fifo_write_ctrl(CLIENT *, int *, unsigned int);
static void fifo_write_tst(CLIENT *, int *, unsigned int);
static void px_get_img(CLIENT *, int *, int *, int *, unsigned int[]);
static void px_set_select(CLIENT *, int *, unsigned int []);
static void fifo_set_level(CLIENT *, int *, int);

#ifdef ENABLE_NFS_WRITE		// sls8x2, slsdet
static void fifo_write_image(CLIENT *, int *, char *, unsigned int [], int);
static void fifo_write_n_images(CLIENT *, int *, char *, unsigned int [],
				unsigned int, unsigned int);
int n_images = 0;
#endif

// global variables
char iocHost[20]="ioc038";		// reset by configuration
unsigned int selectors[17]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
int vpg_default_unit = 1;		// server default is 1
int clock_divider1=-1;
int clock_divider2=-1;

// local variables
static int vpg_is_initialized = 0;
static int fifo_is_initialized = 0;
/******************************************************************************\
**                                                                            **
**      VPG functions                                                         **
**                                                                            **
\******************************************************************************/

/*
**  Load an i2c pattern and execute it
*/
int vpg_execute_pattern( unsigned short thePattern[], int length, int unit)
{
	CLIENT *clnt;
	int err = 0;
	int i, div;
	unsigned short line;

	get_client(&clnt, &err);
	vpg_initialize(clnt, &err);	/* initialize the VME memory mapping */
	vpg_set_default_unit(clnt, &err, unit);
	vpg_clock_stop(clnt, &err);	/* stop the VME clock */
	
		/* set the clock divider */
	if (clock_frequency < 0.9)		// 0 is possible for testing
		div = 15;			// maximum value
	else
		div = -1 + vpg_crystal_frequency/clock_frequency;
	div = max(1, min(div, 15));
	vpg_set_clock_divider(clnt, &err, div);	/* set the clock divider */
	DBG(5,"(rpc_client.c) xtal %f, clk_freq %f, clk_div %d\n",
				vpg_crystal_frequency, clock_frequency, div);
 
#ifdef USE_OLD_CODE
		// progam counter uses line addresses.
		// Thus jump address 1 refers to line 0x80, which is byte address 0x200
			/* load the pattern - start with jump instruction at 0 */
	DBG(4, "Instruction at 0 0x%x\n", 0x80 + (I2C_PATTERN_BASE<<1));
	vpg_write_reg(clnt, &err, 0, 0x80+ (I2C_PATTERN_BASE<<1) );

	line = I2C_PATTERN_BASE;
	for (i=0; i<length; i++)
		{
//		if (!i) 
//			DBG(4, "Instruction at 0x%x : 0x%x\n", 4*line, thePattern[i]<<16);
		vpg_write_reg(clnt, &err, 4*line, (thePattern[i]<<16) );
		line++;
		}
	DBG(4, "Instruction at 0x%x : 0x%x\n", 4*line, 0x00000020);	// a stop
	vpg_write_reg(clnt, &err, 4*line, (thePattern[length-1]<<16)|0x0020 );	// wait instruction

	vpg_reset_program_counter(clnt, &err);	/* reset the program counter */
	vpg_clock_start(clnt, &err);	/* restart the clock */
#else
	line = i2c_pattern_base;
	for (i=0; i<length; i++)
		{
//		if (!i) 
//			DBG(4, "Instruction at 0x%x : 0x%x\n", 4*line, thePattern[i]<<16);
		vpg_write_reg(clnt, &err, 4*line, (thePattern[i]<<16) );
		line++;
		}
	vpg_write_reg(clnt, &err, 4*line, (thePattern[length-1]<<16)|0x0020 );	// wait instruction

	vpg_set_jump_addr(clnt, &err, i2c_pattern_base);
	vpg_clock_start(clnt, &err);	/* restart the clock */
#endif

	/* wait for pattern to be executed */
//	usleep(1000);		// 1 ms
	vpg_wait_pattern(1, vpg_default_unit);

	vpg_clock_stop(clnt, &err);

	client_destroy(clnt, &err);
	return err;
}


/*
**  Load a pattern into the pattern generator
*/
int vpg_load_pattern(char *ptr, int unit)
{
	CLIENT *clnt;
	int err = 0;
	FILE *ifp;
	int i;
	char *p, line[120];
	unsigned short offset=0, lineno;
	unsigned int data, tdata;
	
	if ((p = strchr(ptr, ' ')) != NULL)		// was offset given?
		{
		sscanf(p+1, "%hx", &offset);
		*p = '\0';		// remove offset
		if (offset & VPG_JUMP_MASK)
			{
			printf ("Offset must be multiple of 0x80\n");
			return -1;
			}
		}

	line[0]='\0';
	if (*ptr != '.' && *ptr != '/')		// was a path specified?
		strcpy(line, cam_data_path);	// no, use this path
	DBG(1, "VPG load pattern from %s\n", line);
	strcat(line, ptr);
	if ((ifp = fopen(line, "r")) == NULL)
		{
		printf("Could not open pattern file %s\n", line);
		return -1;
		}
	if (NULL == fgets(line, sizeof(line), ifp))
		{
		printf("File is empty %s\n", ptr);
		fclose(ifp);
		return -1;
		}
	while ((p = findData(line)) == NULL)
		if (NULL == fgets(line, sizeof(line), ifp))
			{
			printf("File is empty %s\n", ptr);
			fclose(ifp);
			return -1;
			};
	sscanf(p, "%hx %x", &lineno, &data);
	lineno += offset;
	if ( (lineno & VPG_JUMP_MASK) )
		{
		printf("Lineno + offset ( %#x ) must be a multiple of 0x80\n", lineno);
		return -1;
		}
	start_line = lineno;		// global start address

	get_client(&clnt, &err);
	vpg_initialize(clnt, &err);	/* initialize the VME memory mapping */
	vpg_set_default_unit(clnt, &err, unit);
	vpg_clock_stop(clnt, &err);	/* stop the VME clock */

		// write the first line
	DBG(4, "Instruction at 0x%x : 0x%x\n", 4*lineno, data);
	vpg_write_reg(clnt, &err, 4*lineno, data);

	i=0;
	while (fgets(line, sizeof(line), ifp))
		{
		if ((p = findData(line)) == NULL)
			continue;
		sscanf(p, "%hx %x", &lineno, &data);
		lineno += offset;
		if (lineno > 0xef00)
			{
			printf("vpg_load_pattern: lineno out of range: %#x\n", lineno);
			goto errRet;
			}
		if (data & 0xd0)	// set address in goto, jump & push
			{
			tdata = ((data & 0xff00)+((offset<<1) & 0xff00));
			if (tdata > 0xff00)
				{
				printf("vpg_load_pattern: address out of range: %#x\n", tdata);
				goto errRet;
				}
			else
				data =  (data & 0xffff00ff) | tdata;
			}
// 		if (!i) 
//			DBG(4, "Instruction at 0x%x : 0x%x\n", 4*lineno, data);
		vpg_write_reg(clnt, &err, 4*lineno, data);
		i++;
		}
	DBG(4, "Instruction at 0x%x : 0x%x\n", 4*lineno, data);

	fclose(ifp);
	client_destroy(clnt, &err);
	return err;

errRet:
	fclose(ifp);
	client_destroy(clnt, &err);
	return -1;
}

// helper for vpg_load_pattern - accept comments and blank lines
static char *findData(char *line)
{
char *p;

if ((p = strchr(line, '#')) != NULL)
	*p = '\0';
if ((p = strchr(line, '!')) != NULL)
	*p = '\0';
p = line;
while (*p && isspace(*p))
	p++;
if (*p)
	return p;
else
	return NULL;
}


/*
**  Wait for pattern to finish, or time-out
*/
void vpg_wait_pattern(int t, int unit)
{
unsigned int input;
time_t endTime, tn, ts;

//printf("Start time: %s\n", timestamp());
ts = tn = time(NULL);			// time now
endTime = (time_t)(t + tn);		// t should be >= 1
input = vpg_read(VPG_INPUT_REG, unit);

while (input&0x80 && tn<endTime)
	{
	usleep(10000);			// 0.01 sec to avoid tying up network
	input = vpg_read(VPG_INPUT_REG, unit);
	tn=time(NULL);
	}

//printf("End time: %s\n", timestamp());

if (tn >= endTime)
	{
	printf(" Timed-out after %d sec\n", t);
	DBG(3, " (vpg_wait_pattern) Timed-out after %d sec\n", t);
	}
else
	{
//	printf(" Wait detected at %d sec.\n", tn-ts);
	DBG(3, " (vpg_wait_pattern) Wait detected at %d sec.\n", (int)(tn-ts));
	}

return;
}


/*
**  Start the vpg clock
*/
int vpg_start_clock(int unit)
{
	CLIENT *clnt;
	int err = 0;

	get_client(&clnt, &err);
	vpg_initialize(clnt, &err);	/* initialize the VME memory mapping */
	vpg_set_default_unit(clnt, &err, unit);
	vpg_clock_start(clnt, &err);	/* restart the clock */
	pgRunning[vpg_default_unit]=True;
	client_destroy(clnt, &err);
	return err;
}


/*
**  Stop the vpg clock
*/
int vpg_stop_clk(int unit)
{
	CLIENT *clnt;
	int err = 0;

	get_client(&clnt, &err);
	vpg_initialize(clnt, &err);	/* initialize the VME memory mapping */
	vpg_set_default_unit(clnt, &err, unit);
	vpg_clock_stop(clnt, &err);	/* stop the VME clock */
	pgRunning[vpg_default_unit]=False;
	client_destroy(clnt, &err);
	return err;
}


/*
**  Set the pattern generator program counter to 0
*/
int vpg_pc_reset(int unit)
{
	CLIENT *clnt;
	int err = 0;

	get_client(&clnt, &err);
	vpg_initialize(clnt, &err);	/* initialize the VME memory mapping */
	vpg_set_default_unit(clnt, &err, unit);
	vpg_reset_program_counter(clnt, &err);	/* reset the program counter */
	client_destroy(clnt, &err);
	return err;
}


/*
**  Set the pattern generator program counter to start address
*/
int vpg_set_jump(unsigned int addr, int unit)
{
	CLIENT *clnt;
	int err = 0;

	if (addr & VPG_JUMP_MASK)
		{
		printf("Address ( %#x ) must be a multiple of 0x80\n", addr);
		return -1;
		}

	get_client(&clnt, &err);
	vpg_initialize(clnt, &err);	/* initialize the VME memory mapping */
	vpg_set_default_unit(clnt, &err, unit);
	vpg_set_jump_addr(clnt, &err, addr);
	client_destroy(clnt, &err);
	return err;
}


/*
**  Set the vpg clock divider
*/
int vpg_set_clk_divider(int div, int unit)
{
	CLIENT *clnt;
	int err = 0;

	get_client(&clnt, &err);
	vpg_initialize(clnt, &err);	/* initialize the VME memory mapping */
	vpg_set_default_unit(clnt, &err, unit);

	vpg_set_clock_divider(clnt, &err, div);	/* set the clock divider */

	client_destroy(clnt, &err);
	return err;
}


/*
**  Initialize the pattern generator(s)
*/
int vpg_init(void)
{
	CLIENT *clnt;
	int err = 0;

	vpg_is_initialized = 0;		// force reinitialization by this call
	get_client(&clnt, &err);
	vpg_initialize(clnt, &err);	/* initialize the VME memory mapping */
	vpg_set_default_unit(clnt, &err, 1);	// set unit 1 as default
	client_destroy(clnt, &err);
	return err;
}


/*
**  Clear the memory of the pattern generator
*/
int vpg_clear(int unit)
{
	CLIENT *clnt;
	int err = 0;

	get_client(&clnt, &err);
	vpg_initialize(clnt, &err);	/* initialize the VME memory mapping */
	vpg_set_default_unit(clnt, &err, unit);
	vpg_clear_memory(clnt, &err);
	client_destroy(clnt, &err);
	return err;
}


/*
**  Single step the pattern generator
*/
int vpg_step(int unit)
{
	CLIENT *clnt;
	int err = 0;

	get_client(&clnt, &err);
	vpg_set_default_unit(clnt, &err, unit);
	vpg_step_clk(clnt, &err);
	client_destroy(clnt, &err);
	return err;
}


/*
**  Read vpg status
*/
unsigned int vpg_read_status(int unit)
{
return vpg_read(VPG_STATUS_REG, unit);
}


/*
**  Read vpg status and print
*/
void vpg_read_status_p(int unit)
{
printf("VPG status: %#x\n", vpg_read_status(unit));
return;
}


/*
**  Read vpg register and print
*/
void vpg_read_p(unsigned int addr, int unit)
{
printf("VPG read register %#x : %#x\n", addr, vpg_read(addr, unit) );
return;
}


/*
**  Read vpg register
*/
unsigned int vpg_read(unsigned int addr, int unit)
{
	CLIENT *clnt;
	int err = 0;
	unsigned int data;

	get_client(&clnt, &err);
	vpg_initialize(clnt, &err);	/* initialize the VME memory mapping */
	vpg_set_default_unit(clnt, &err, unit);
	vpg_read_reg(clnt, &err, addr, &data);
	client_destroy(clnt, &err);
	return data;
}


/*
**  Write to vpg status register
*/
int vpg_write_status(unsigned int data, int unit)
{
return vpg_write(VPG_STATUS_REG, data, unit);
}


/*
**  Write to vpg register
*/
int vpg_write(unsigned int addr, unsigned int data, int unit)
{
	CLIENT *clnt;
	int err = 0;

	get_client(&clnt, &err);
	vpg_initialize(clnt, &err);	/* initialize the VME memory mapping */
	vpg_set_default_unit(clnt, &err, unit);

//	printf("VPG write register %#x : %#x\n", addr, data);
	vpg_write_reg(clnt, &err, addr, data);

	client_destroy(clnt, &err);
	return err;
}


/*
** Set the default VPG unit to 1 or 2
*/
int vpg_set_default(int unit)
{
	int err = 0;

#ifdef TWO_VPGS					/* becomes a no-op with 1 VPG */
	CLIENT *clnt;

	get_client(&clnt, &err);
	vpg_initialize(clnt, &err);	/* initialize the VME memory mapping */

	vpg_set_default_unit(clnt, &err, unit);

	client_destroy(clnt, &err);
#endif
	
	return err;
}



/******************************************************************************\
**                                                                            **
**      FIFO functions                                                        **
**                                                                            **
\******************************************************************************/

/*
**  Initialize the fifo
*/
int fifo_init(void)
{
	CLIENT *clnt;
	int err = 0;

	fifo_is_initialized = 0;		// force an initialization
	get_client(&clnt, &err);
	fifo_initialize(clnt, &err);	/* initialize the VME memory mapping */
	client_destroy(clnt, &err);
	return err;
}


/*
**  Write fifo register
*/
int fifo_write(unsigned int addr, unsigned int data)
{
	CLIENT *clnt;
	int err = 0;

	get_client(&clnt, &err);

	fifo_write_reg(clnt, &err, addr, data);
	printf("FIFO write register %#x : %#x\n", addr, data);

	client_destroy(clnt, &err);
	return err;
}


/*
**  Fifo write to control register
*/
int fifo_write_control(unsigned int data)
{
	CLIENT *clnt;
	int err = 0;

	get_client(&clnt, &err);

	fifo_write_ctrl(clnt, &err, data);

	client_destroy(clnt, &err);
	return err;
}


/*
**  Fifo write to test register
*/
int fifo_write_test(unsigned int data)
{
	CLIENT *clnt;
	int err = 0;

	get_client(&clnt, &err);

	fifo_write_tst(clnt, &err, data);

	client_destroy(clnt, &err);
	return err;
}


/*
**  Write sequential data to the fifo data register
*/
int fifo_write_data(unsigned int data)
{
	CLIENT *clnt;
	int err = 0;

	get_client(&clnt, &err);

	fifo_write_dat(clnt, &err, data);

	client_destroy(clnt, &err);
	return err;
}


/*
**  Read fifo status
*/
int fifo_read_status(void)
{
	CLIENT *clnt;
	int err = 0;
	unsigned int data;

	get_client(&clnt, &err);
	fifo_read_stat(clnt, &err, &data);
	client_destroy(clnt, &err);
	if (err)
		return -1;
	else
		return data & 0xff;
}


/*
**  Read fifo status & print
*/
void fifo_read_status_p(void)
{
	printf("FIFO status %#x \n", fifo_read_status() & 0xff);
	return;
}


/*
**  Wait while fifo is busy up to 'timeout' seconds
*/
int fifo_wait_busy(int timeout)
{
	CLIENT *clnt;
	int err = 0;
	unsigned int status;
	time_t endTime;

	endTime = (time_t)(timeout + time(NULL));
	get_client(&clnt, &err);

	fifo_read_stat(clnt, &err, &status);
	while( (status&0x10) && time(NULL)<endTime && !err)
		fifo_read_stat(clnt, &err, &status);

	client_destroy(clnt, &err);
	return err;
}


/*
**  Read fifo register
*/
int fifo_read(unsigned int addr)
{
	CLIENT *clnt;
	int err = 0;
	unsigned int data;

	get_client(&clnt, &err);

	fifo_read_reg(clnt, &err, addr, &data);
	printf("FIFO read register %#x : %#x\n", addr, data);

	client_destroy(clnt, &err);
	return err;
}


/*
**  Read the fifo event register
*/
int fifo_read_event(void)
{
	CLIENT *clnt;
	int err = 0;
	unsigned int data;

	get_client(&clnt, &err);

	fifo_read_event_ctr(clnt, &err, &data);		// data were masked in ioc
	printf("FIFO event counter %#x\n", data);

	client_destroy(clnt, &err);
	return err;
}


/*
**  Read sequential data from the fifo data register
*/
int fifo_read_data(void)
{
	CLIENT *clnt;
	int err = 0;
	unsigned int data;

	get_client(&clnt, &err);

	fifo_read_dat(clnt, &err, &data);
	printf("FIFO data register %#x\n", data);

	client_destroy(clnt, &err);
	return err;
}


/*
**  Read an image from the fifo
*/
int fifo_read_image(void)
{
	CLIENT *clnt;
	int err = 0, npix=0, len=0;

	imageLength = 0;
	get_client(&clnt, &err);

	// the selector is a bit pattern saying which column of data from the
	// fifo correpsonds to which chip - so, chip no. 1 could be col 3, etc.
	// At least 1 column must be selected.  The selectors array is read
	// by cam_tbl.c from the camera definition file.

	// if more than 1 selector is used, the images are arranged in the 8x2 chip
	// format in theImage[].

	px_set_select(clnt, &err, selectors);
	
/*
**  There is a limit of about 500 u_shorts per rpc transfer - probably all
**  data for 1 transfer must fit into a single udp packet.
**  So, to transfer an image, we must make multiple calls and reassemble
**  the result on this side of the connection.
**  npix is the total number of pixels available, len is the number transferred
**  in this call.
*/
	px_get_img(clnt, &err, &npix, &len, &theImage[0]);
	imageLength += len;
//	printf("Get image %d pixels: recd %d, total %d\n", npix, len, imageLength);
	while (imageLength < npix && len)
		{
		px_get_img(clnt, &err, &npix, &len, &theImage[imageLength]);
		imageLength += len;
//		printf("Get image %d pixels: recd %d, total %d\n", npix, len, imageLength);
		}
	if (imageLength < npix)
		{
		printf("***Get image %d pixels: recd only %d pixels\n", npix, imageLength);
		DBG(1, "***Get image %d pixels: recd only %d pixels\n", npix, imageLength);
		}


	client_destroy(clnt, &err);
	return err;
}


int write_image_nfs(char *path, int mode)
{
	int err = 0;

#ifdef ENABLE_NFS_WRITE				/* becomes a no-op in sls42 */
	CLIENT *clnt;

	get_client(&clnt, &err);

	fifo_write_image(clnt, &err, path, selectors, mode);
	if (err)
		printf("ERROR writing image file: %s\n", path);
	pgRunning[vpg_default_unit] = True;

	client_destroy(clnt, &err);
#endif

	return err;
}

#ifndef SLS42_CAMERA
// exptime is not actually used in fifo.c
int write_n_images_nfs(char *path, unsigned int nimages, unsigned int exptime)
{
	int err = 0;

#ifdef ENABLE_NFS_WRITE				/* becomes a no-op in sls42 */
	CLIENT *clnt;

	get_client(&clnt, &err);

	fifo_write_n_images(clnt, &err, path, selectors, nimages, exptime);
	if (err)
		printf("ERROR writing image file: %s\n", path);
	pgRunning[vpg_default_unit] = True;

	client_destroy(clnt, &err);
#endif

	return err;
}
#endif



int fifo_set_true_level(int value)
{
	CLIENT *clnt;
	int err = 0;

#ifdef SLS42_CAMERA
	return err;			// no xor functions in ioc
#endif
	get_client(&clnt, &err);
	fifo_set_level(clnt, &err, value);
	client_destroy(clnt, &err);
	return err;
}

/******************************************************************************\
**                                                                            **
**      Atomic functions - used to build complex functions                    **
**                                                                            **
**      The structure adopted here is primarily to allow clean, easily        **
**      read implementations, at the expense of a little overhead.            **
**      Each routine becomes a null operation if err is set.                  **
**                                                                            **
\******************************************************************************/


static void get_client(CLIENT **clnt, int *err)
{
//	char host[] = HOST;

	if (*err)
		return;

	*clnt = clnt_create(iocHost, rpcfns, TWO, "udp");
	if (*clnt == NULL)
		{
		clnt_pcreateerror(iocHost);
		*err = -1;
		}
	return;
}

static void vpg_initialize(CLIENT *clnt, int *err)
{
	int  *result_17;
	char*  rpc_vpg_vpgini_2_arg;

	if (vpg_is_initialized || *err)
		return;

	/* initialize the VME memory mapping */
	result_17 = rpc_vpg_vpgini_2((void*)&rpc_vpg_vpgini_2_arg, clnt);
	if (result_17 == NULL)
		{
		clnt_perror(clnt, "vpgini call failed:\n");
		clnt_destroy( clnt );
		*err = -1;
		}
	if (*err == 0)
		vpg_is_initialized = 1;
	return;
}

static void vpg_clock_stop(CLIENT *clnt, int *err)
{
	int  *result_14;
	char*  rpc_vpg_clk_stop_2_arg;

	if (*err)
		return;

	/* stop the VME clock */
	result_14 = rpc_vpg_clk_stop_2((void*)&rpc_vpg_clk_stop_2_arg, clnt);
	if (result_14 == NULL)
		{
		clnt_perror(clnt, "clk_stop call failed:\n");
		clnt_destroy( clnt );
		*err = -1;
		}
	pgRunning[vpg_default_unit] = False;
	return;
}


static void vpg_clock_start(CLIENT *clnt, int *err)
{
	int  *result_13;
	char*  rpc_vpg_clk_start_2_arg;

	if (*err)
		return;

	/* restart the clock */
	result_13 = rpc_vpg_clk_start_2((void*)&rpc_vpg_clk_start_2_arg, clnt);
	if (result_13 == NULL)
		{
		clnt_perror(clnt, "clk_start call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	pgRunning[vpg_default_unit] = True;
	return;
}


static void vpg_set_clock_divider(CLIENT *clnt, int *err, int div)
{
	int  *result_3;
	vpg  rpc_vpg_set_clk_divider_2_arg;

	if (*err)
		return;

	div = max(MIN_CLOCK, min(div, MAX_CLOCK));
	rpc_vpg_set_clk_divider_2_arg.patname = "\0";	// keep xdr happy
	rpc_vpg_set_clk_divider_2_arg.divider = div;
	DBG(5, "Setting clock divider to %d\n", div);

	result_3 = rpc_vpg_set_clk_divider_2(&rpc_vpg_set_clk_divider_2_arg, clnt);
	if (result_3 == NULL)
		{
		clnt_perror(clnt, "clk_divider call failed:\n");
		clnt_destroy( clnt );
		*err =  -1;
		}
	if (vpg_default_unit == 2)				// remember the value
		clock_divider2 = div;
	else
		clock_divider1 = div;

	return;
}


static void vpg_clear_memory(CLIENT *clnt, int *err)
{
	int  *result_16;
	char*  rpc_vpg_clr_mem_2_arg;

	if (*err)
		return;

	result_16 = rpc_vpg_clr_mem_2((void*)&rpc_vpg_clr_mem_2_arg, clnt);
	if (result_16 == NULL)
		{
		clnt_perror(clnt, "call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
return;
}


static void vpg_step_clk(CLIENT *clnt, int *err)
{
	int  *result_9;
	char*  rpc_vpg_clk_2_arg;

	if (*err)
		return;

	result_9 = rpc_vpg_clk_2((void*)&rpc_vpg_clk_2_arg, clnt);
	if (result_9 == NULL)
		{
		clnt_perror(clnt, "call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
return;
}


static void vpg_read_reg(CLIENT *clnt, int *err, unsigned int addr, unsigned int *data)
{
	int  *result_2;
	address  rpc_vpg_read_a32_2_arg;

	if (*err)
		return;

	rpc_vpg_read_a32_2_arg.addr = addr;			// a jump instruction at 0
	result_2 = rpc_vpg_read_a32_2(&rpc_vpg_read_a32_2_arg, clnt);
	if (result_2 == NULL)
		{
		clnt_perror(clnt, "read call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	else
		*data = *result_2;
	return;
}


static void vpg_write_reg(CLIENT *clnt, int *err, unsigned int addr, unsigned int data)
{
	int  *result_1;
	address  rpc_vpg_write_a32_2_arg;

	if (*err)
		return;

	rpc_vpg_write_a32_2_arg.addr = addr;			// a jump instruction at 0
	rpc_vpg_write_a32_2_arg.data = data;
	result_1 = rpc_vpg_write_a32_2(&rpc_vpg_write_a32_2_arg, clnt);
	if (result_1 == NULL)
		{
		clnt_perror(clnt, "write_vme call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	return;
}

static void vpg_reset_program_counter(CLIENT *clnt, int *err)
{
	int  *result_15;
	char*  rpc_vpg_pc_reset_2_arg;

	if (*err)
		return;

	/* reset the program counter */
	result_15 = rpc_vpg_pc_reset_2((void*)&rpc_vpg_pc_reset_2_arg, clnt);
	if (result_15 == NULL)
		{
		clnt_perror(clnt, "pc_reset call failed:");
		clnt_destroy( clnt );
		*err = -1;
		}
	return;
}


static void vpg_set_jump_addr(CLIENT *clnt, int *err, unsigned int addr)
{
	int  *result_8;
	vpg  rpc_vpg_jump_2_arg;

	if (*err)
		return;

	rpc_vpg_jump_2_arg.patname = "\0";	// keep xdr happy
	rpc_vpg_jump_2_arg.addr = addr;

	result_8 = rpc_vpg_jump_2(&rpc_vpg_jump_2_arg, clnt);
	if (result_8 == NULL)
		{
		clnt_perror(clnt, "set jump address call failed:");
		clnt_destroy( clnt );
		*err = -1;
		}
	return;
}


static void client_destroy(CLIENT *clnt, int *err)
{
	if (*err)
		return;

	clnt_destroy( clnt );
	return;
}


static void fifo_initialize(CLIENT *clnt, int *err)
{
	int  *result_20;
	char*  rpc_fifo_fifoini_2_arg;

	if(fifo_is_initialized || *err)
		return;

	result_20 = rpc_fifo_fifoini_2((void*)&rpc_fifo_fifoini_2_arg, clnt);
	if (result_20 == NULL)
		{
		clnt_perror(clnt, "fifoini call failed:");
		clnt_destroy( clnt );
		*err = -1;
		}
	if (*err == 0)
		fifo_is_initialized = 1;
	return;
}


static void fifo_read_reg(CLIENT *clnt, int *err, unsigned int addr, unsigned int *data)
{
	int  *result_18;
	address  rpc_fifo_read_d32_2_arg;

	if (*err)
		return;

	rpc_fifo_read_d32_2_arg.addr = addr;
	result_18 = rpc_fifo_read_d32_2(&rpc_fifo_read_d32_2_arg, clnt);
	if (result_18 == NULL)
		{
		clnt_perror(clnt, "fifo read call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	else
		*data = *result_18;
	return;
}


static void fifo_write_reg(CLIENT *clnt, int *err, unsigned int addr, unsigned int data)
{
	int  *result_19;
	address  rpc_fifo_write_d32_2_arg;

	if (*err)
		return;

	rpc_fifo_write_d32_2_arg.addr = addr;
	rpc_fifo_write_d32_2_arg.data = data;
	result_19 = rpc_fifo_write_d32_2(&rpc_fifo_write_d32_2_arg, clnt);
	if (result_19 == NULL)
		{
		clnt_perror(clnt, "fifo write reg call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	return;
}


static void fifo_read_stat(CLIENT *clnt, int *err, unsigned int *data)
{
	int  *result_23;
	address  rpc_fifo_read_status_2_arg;

	if (*err)
		return;

	result_23 = rpc_fifo_read_status_2(&rpc_fifo_read_status_2_arg, clnt);
	if (result_23 == NULL)
		{
		clnt_perror(clnt, "fifo read status call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	else
		*data = *result_23;
	return;
}


static void fifo_read_dat(CLIENT *clnt, int *err, unsigned int *data)
{
	int  *result_21;
	address  rpc_fifo_read_data_2_arg;

	if (*err)
		return;

	result_21 = rpc_fifo_read_data_2(&rpc_fifo_read_data_2_arg, clnt);
	if (result_21 == NULL)
		{
		clnt_perror(clnt, "fifo_read_dat call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	else
		*data =*result_21;
	return;
}


static void fifo_read_event_ctr(CLIENT *clnt, int *err, unsigned int *data)
{
	int  *result_22;
	address  rpc_fifo_read_event_cntr_2_arg;

	if (*err)
		return;

	result_22 = rpc_fifo_read_event_cntr_2(&rpc_fifo_read_event_cntr_2_arg, clnt);
	if (result_22 == NULL)
		{
		clnt_perror(clnt, "fifo_read_event_ctr call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	else
		*data =*result_22;
	return;
}


static void fifo_write_dat(CLIENT *clnt, int *err, unsigned int data)
{
	int  *result_24;
	address  rpc_fifo_write_data_2_arg;

	if (*err)
		return;

	rpc_fifo_write_data_2_arg.data = data;
	result_24 = rpc_fifo_write_data_2(&rpc_fifo_write_data_2_arg, clnt);
	if (result_24 == NULL)
		{
		clnt_perror(clnt, "fifo_write_dat call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	return;
}


static void fifo_write_ctrl(CLIENT *clnt, int *err, unsigned int data)
{
	int  *result_25;
	address  rpc_fifo_write_control_2_arg;

	if (*err)
		return;

	rpc_fifo_write_control_2_arg.data = data;
	result_25 = rpc_fifo_write_control_2(&rpc_fifo_write_control_2_arg, clnt);
	if (result_25 == NULL)
		{
		clnt_perror(clnt, "fifo_write_ctrl call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	return;
}


static void fifo_write_tst(CLIENT *clnt, int *err, unsigned int data)
{
	int  *result_26;
	address  rpc_fifo_write_test_2_arg;

	if (*err)
		return;

	rpc_fifo_write_test_2_arg.data = data;
	result_26 = rpc_fifo_write_test_2(&rpc_fifo_write_test_2_arg, clnt);
	if (result_26 == NULL)
		{
		clnt_perror(clnt, "fifo_write_tst call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	return;
}


static void px_get_img(CLIENT *clnt, int *err, int *n, int *len, unsigned int data[])
{
	int i;
	image  *result_27;
	char*  rpc_px_read_image_2_arg;

	if (*err)
		return;

	result_27 = rpc_px_read_image_2((void*)&rpc_px_read_image_2_arg, clnt);
	if (result_27 == NULL)
		{
		clnt_perror(clnt, "px_get_img call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	else
		{
		*n = result_27->npix;
		*len = result_27->img.img_len;
		for (i=0; i<result_27->img.img_len; i++)
			data[i] = result_27->img.img_val[i];
		}
	return;
}


static void px_set_select(CLIENT *clnt, int *err, unsigned int data[])
{
	int  *result_28;
	arry  rpc_px_set_selector_2_arg;

	if (*err)
		return;

	rpc_px_set_selector_2_arg.data.data_len = NSELECTORS;
	rpc_px_set_selector_2_arg.data.data_val = data;

	result_28 = rpc_px_set_selector_2(&rpc_px_set_selector_2_arg, clnt);
	if (result_28 == NULL)
		{
		clnt_perror(clnt, "px_set_select call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}
	return;
}


static void vpg_set_default_unit(CLIENT *clnt, int *err, int unit)
{
#ifdef TWO_VPGS
	int  *result_29;
	int  rpc_vpg_set_default_2_arg = unit;

	if (*err)
		return;

	if (unit == vpg_default_unit)
		return;					// no action required

	if (unit<1 || unit>2)
		{
		printf("Illegal VPG unit number: %d\n", unit);
		*err = -1;
		return;
		}
	
	DBG(5, "(rpc_client.c) Setting default VPG unit to %d\n", 
				rpc_vpg_set_default_2_arg);

	result_29 = rpc_vpg_set_default_2(&rpc_vpg_set_default_2_arg, clnt);
	if (result_29 == NULL) 
		{
		clnt_perror(clnt, "rpc_vpg_set_default call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}

	*err = *result_29;

	if (*err)
		printf("Error setting default vpg: %d\n", unit);
	else
		vpg_default_unit = unit;

	return;
#endif
}


#ifdef ENABLE_NFS_WRITE
static void fifo_write_image(CLIENT *clnt, int *err, char *path,
				unsigned int data[], int mode)
{
	int  *result_30;
	image_spec  rpc_fifo_write_image_2_arg;

	if (*err)
		return;

	rpc_fifo_write_image_2_arg.patname = path;
	rpc_fifo_write_image_2_arg.data.data_len = NSELECTORS;
	rpc_fifo_write_image_2_arg.data.data_val = data;
	rpc_fifo_write_image_2_arg.mode = mode;

	result_30 = rpc_fifo_write_image_2(&rpc_fifo_write_image_2_arg, clnt);

	if (result_30 == NULL)
		{
		clnt_perror(clnt, "rpc_fifo_write_image call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}

	return;
}

static void fifo_write_n_images(CLIENT *clnt, int *err, char *path,
				unsigned int data[], unsigned int nimg, unsigned int etime)
{
	int  *result_51;
	n_image_spec rpc_fifo_write_n_images_2_arg;
	
	if (*err)
		return;

	rpc_fifo_write_n_images_2_arg.patname = path;
	rpc_fifo_write_n_images_2_arg.data.data_len = NSELECTORS;
	rpc_fifo_write_n_images_2_arg.data.data_val = data;
	rpc_fifo_write_n_images_2_arg.nimg = nimg;
	rpc_fifo_write_n_images_2_arg.etime = etime;

	result_51 = rpc_fifo_write_n_images_2(&rpc_fifo_write_n_images_2_arg, clnt);

	if (result_51 == NULL)
		{
	
		clnt_perror(clnt, "rpc_fifo_write_image call failed:");
		clnt_destroy( clnt );
		*err =  -1;
		}

	return;
	
}
#endif


#undef ENABLE_NFS_WRITE



static void fifo_set_level(CLIENT *clnt, int *err, int data)
{
#ifndef SLS42_CAMERA
	int *result_31;
	int  rpc_fifo_set_level_2_arg = data;

	if (*err)
		return;

	result_31 = rpc_fifo_set_level_2(&rpc_fifo_set_level_2_arg, clnt);
	if (result_31 == NULL)
		{
		clnt_perror(clnt, "fifo_set_level failed:");
		clnt_destroy( clnt );
		*err = -1;
		}
#endif
	return;
}
